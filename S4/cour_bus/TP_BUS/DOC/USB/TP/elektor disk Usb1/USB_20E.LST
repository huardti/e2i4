CYASM Version 1.75
(C) 1997 Cypress Semiconductor Corp.

0000            ;; USB_20.ASM
0000            ;*******************************************************************************
0000            ;
0000            ; *******************************************************************************
0000            ;
0000            ; Target:
0000            ;       Cypress 7C63000 8bit RISC microcontroller with 1.5Mbps USB serial interface 
0000            ;       Dallas 1623: High Resolution Temperature Measurement Sensor
0000            ; Overview
0000            ;  There are four main sub-systems: USB, Thermometer, LED, and Button. 
0000            ;   The system is started in the main() routine at reset. This routine 
0000            ;   initializes the USB variables, the IO ports, the Thermometer logic, 
0000            ;   and the data space. All USB communication occurs on an interrupt basis.
0000            ;  First, Main() loops waiting for a USB reset.
0000            ;  After receiving a USB reset, Main() enables the Endpoint 0 interrupt and 
0000            ;   loops waiting for Setups which ultimately will the result in the device 
0000            ;   being enumerated.
0000            ;  Once the device has been enumerated on the USB, the main loop waits 10ms, 
0000            ;   polls the thermometer, updates the LED, and initializes end point 1 if 
0000            ;   appropriate.
0000            ; USB
0000            ;  Endpoint 0 is used to support Control Transfers and vendor specific 
0000            ;   requests. End point 1 is also available for interrupt requests handling
0000            ;   small packets of data (good for mouse, joystick, keyboard, thermometer, etc.).
0000            ;   However, it is not used in this code.
0000            ;  Each control transfer interrupts the processor and the subsequent routines
0000            ;   services it.
0000            ; Thermometer
0000            ;  A simple 9-bit temperature value is read from the thermometer every 10ms. At
0000            ;   startup, the thermometer is initialized and placed into a continuous mode 
0000            ;   storing internally the current temperature. Thereafter, the temperature is 
0000            ;   read synchronously and returned into the USB end point one FIFO buffer.
0000            ; LED
0000            ;  The LED is controlled by P13. When P13 goes low, the LED is turned on.
0000            ;   The LED indicates the status of the USB connection. Once this device has
0000            ;   "logically" been enumerated and configured to run on the serial bus, the LED
0000            ;   is illuminated. The LED supports adjusting the brightness intensity by first
0000            ;   setting the new brightens value (default: FFh = High) and then setting the 
0000            ;   brightness update field.
0000            ; Button
0000            ;  A momentary push button is used to indicate that the application's 
0000            ;   Celsius/Fahrenheit display mode should be toggled.
0000            ;  With each GetTemperature request, a value is sent indicating whether the
0000            ;   button has been pushed.  
0000            ;  The GPIO interrupt is triggered by pushing the button causing its 
0000            ;   level to change from High to Low. A 100ms debounce was added to control the
0000            ;   erroneous re-occurrence of this logical state change for a period. The
0000            ;   1024ms timer decrements the debounce to zero, re-enabling the button if at the
0000            ;   end of the time out it has returned High.
0000            ;
0000            ; Port Usage
0000            ;  P0.0 - Thermometer Data  (input/output)
0000            ;    .1 - Thermometer Clock (output)
0000            ;    .2 - Thermometer Reset (output)
0000            ;    .3 - 
0000            ;    .4 -
0000            ;    .5 -
0000            ;    .6 -
0000            ;    .7 -
0000            ;  P1.0 -
0000            ;    .1 -
0000            ;    .2 - Button (0=pushed) (input)
0000            ;    .3 - LED (0=on)        (output)
0000            ;
0000            ;*******************************************************************************
0000            
0000            ;//$PAGE
0000            ; Directives
0000            FillROM 0
0000            
0000            ; Microprocessor definitions
0000            ;;******************************************************************************
0000            ;; C7C63x0x.h - Cypress Semiconductor Cy7C63x0x micrprocessor definitions
0000            ;; Copyright (c) Slade Systems, Inc, 1997
0000            ;;
0000            ;; Cypress Semiconductor Corp.
0000            ;; 12032 113th Ave NE, Kirkland, WA 98034
0000            ;; 206-821-9202 - 206-820-8959(f)
0000            ;;
0000            ;;******************************************************************************
0000            
0000            
0000            ;*******************************************************************************
0000            ;
0000            ; M8 - 8bit microprocessor
0000            ; registers: accumulator     'acc'
0000            ;            index           'x'
0000            ;            stack pointer   'dsp'
0000            ;            program SP      'psp'
0000            ;            program counter 'pc'  16 bits (14 bit addressing)
0000            ;             PC low         'pcl'
0000            ;             PC high        'pch'
0000            ; When PC is pushed on stack
0000            ;  carry flag is stored in bit 14
0000            ;  zero  flag is stored in bit 15
0000            ;
0000            ; Program ROM 4096 bytes in 256 byte pages
0000            ; Program RAM  128 bytes
0000            ; Processor PORTs contain 16k-ohm resistor (pull-up and slew control)
0000            ;
0000            ; After reset:
0000            ;  Port 0 and Port 1 are set high
0000            ;
0000            ;
0000            ;*******************************************************************************
0000            
0000            ;*************************************************
0000            ;
0000            ; I/O ports defined
0000            SysPort0                   :equ 00h     ; GPIO data port 0 (P00-P07)
0000            SysPort1                   :equ 01h     ; GPIO data port 1 (P10-P13)
0000            SysPort0IntEnable          :equ 04h     ; Port0 Interrupt Enable 
0000            SysPort1IntEnable          :equ 05h     ; Port1 Interrupt Enable 
0000            SysPort0PullUp             :equ 08h     ; Port0 PullUp Resistor Enable (0=active)
0000            SysPort1PullUp             :equ 09h     ; Port1 PullUp Resistor Enable (0=active)
0000            
0000            ; General
0000            SysStatus                  :equ FFh     ;
0000             SysStatusRun              :equ 01h     ;
0000             SysStatusReserved2        :equ 02h     ; nul
0000             SysStatusReserved3        :equ 04h     ; nul
0000             SysStatusSuspend          :equ 08h     ; write only (restart =256us)
0000             SysStatusPowerOn          :equ 10h     ;
0000             SysStatusUSBReset         :equ 20h     ;
0000             SysStatusWDReset          :equ 40h     ;
0000             SysStatusReserved7        :equ 80h     ; nul
0000            SysWatchDog                :equ 21h     ; WatchDog controller
0000            SysTimerExternal           :equ 22h     ; Timer also ???
0000            SysTimer                   :equ 23h     ; Timer (read only) {6MHZ=1us resolution}
0000            SysInterrupt               :equ 20h     ; Global interrupt
0000             SysIntReserved0           :equ 01h     ;
0000             SysIntTimer128us          :equ 02h     ;
0000             SysIntTimer1024us         :equ 04h     ;
0000             SysIntUSBEndP0            :equ 08h     ;
0000             SysIntUSBEndP1            :equ 10h     ;
0000             SysIntReserved5           :equ 20h     ;
0000             SysIntGPIO                :equ 40h     ;
0000             SysIntWakeUp              :equ 80h     ;
0000            
0000            ; Ouput ISink ???
0000            SysPort0ISinkPin0          :equ 30h     ;
0000            SysPort0ISinkPin1          :equ 31h     ;
0000            SysPort0ISinkPin2          :equ 32h     ;
0000            SysPort0ISinkPin3          :equ 33h     ;
0000            SysPort0ISinkPin4          :equ 34h     ;
0000            SysPort0ISinkPin5          :equ 35h     ;
0000            SysPort0ISinkPin6          :equ 36h     ;
0000            SysPort0ISinkPin7          :equ 37h     ;
0000            SysPort1ISinkPin0          :equ 38h     ;
0000            SysPort1ISinkPin1          :equ 39h     ;
0000            SysPort1ISinkPin2          :equ 3Ah     ;
0000            SysPort1ISinkPin3          :equ 3Bh     ;
0000            
0000            ; USB FIFOs
0000            USBEndP0FIFO               :equ 70h
0000            USBEndP0FIFO_0             :equ 70h     ; Will contain CRC if (rx count <8)
0000            USBEndP0FIFO_1             :equ 71h
0000            USBEndP0FIFO_2             :equ 72h
0000            USBEndP0FIFO_3             :equ 73h
0000            USBEndP0FIFO_4             :equ 74h
0000            USBEndP0FIFO_5             :equ 75h
0000            USBEndP0FIFO_6             :equ 76h
0000            USBEndP0FIFO_7             :equ 77h
0000            ;
0000            USBEndP1FIFO               :equ 78h
0000            USBEndP1FIFO_0             :equ 78h
0000            USBEndP1FIFO_1             :equ 79h
0000            USBEndP1FIFO_2             :equ 7Ah
0000            USBEndP1FIFO_3             :equ 7Bh
0000            USBEndP1FIFO_4             :equ 7Ch
0000            USBEndP1FIFO_5             :equ 7Dh
0000            USBEndP1FIFO_6             :equ 7Eh
0000            USBEndP1FIFO_7             :equ 7Fh
0000            
0000            ;*************************************************
0000            ;
0000            USBDeviceAddress           :equ 12h     ; Assigned device address
0000            
0000            ; USB port control
0000            USBControl                 :equ 13h     ; Status/Control register
0000             USBControlBusActive       :equ 01h     ; 1=active, write 0 and watch if bus dies
0000             USBControlResume          :equ 02h     ; set transmitter to k state sending resume to host ???
0000             USBControlReserve2        :equ 04h
0000             USBControlAckStatusData   :equ 08h     ; Auto ACK Data1 SETUP OUT data packets
0000             USBControlAckOutData      :equ 10h     ; Auto ACK Data1 OUT       data packets
0000             USBControlReserve5        :equ 20h
0000             USBControlReserve6        :equ 40h
0000             USBControlReserve7        :equ 80h
0000            
0000            USBEndP0RxStatus           :equ 14h     ; Port0 receive status
0000             USBEndP0RxSetup           :equ 01h     ; 1=setup token received (must be cleared to write FIFOs ???)
0000             USBEndP0RxOut             :equ 02h     ; 1=out   token received
0000             USBEndP0RxIn              :equ 04h     ; 1=in    token received
0000             USBEndP0RxDataFlag        :equ 08h
0000             USBEndP0RxCount0          :equ 10h     ; size =count -2 (two bytes of CRC)
0000             USBEndP0RxCount1          :equ 20h
0000             USBEndP0RxCount2          :equ 40h
0000             USBEndP0RxCount3          :equ 80h
0000            
0000            USBEndP0TxConfig           :equ 10h     ; Transmit configuration
0000             USBEndP0TxCount0          :equ 01h
0000             USBEndP0TxCount1          :equ 02h
0000             USBEndP0TxCount2          :equ 04h
0000             USBEndP0TxCount3          :equ 08h
0000             USBEndP0TxRxErr           :equ 10h     ; read and write
0000             USBEndP0TxStall           :equ 20h     ;
0000             USBEndP0TxSequence        :equ 40h     ;
0000             USBEndP0TxRespond         :equ 80h     ;
0000            
0000            USBEndP1TxConfig           :equ 11h     ;
0000             USBEndP1TxCount0          :equ 01h
0000             USBEndP1TxCount1          :equ 02h
0000             USBEndP1TxCount2          :equ 04h
0000             USBEndP1TxCount3          :equ 08h
0000             USBEndP1TxEnable          :equ 10h     ;
0000             USBEndP1TxStall           :equ 20h     ;
0000             USBEndP1TxSequence        :equ 40h     ;
0000             USBEndP1TxRespond         :equ 80h
0000            
0000            ;*************************************************
0000            ; USB Protocol
0000            ;union USBRqst
0000            ;{   struct
0000            ;    {   BYTE bReceipient :5;    // 0=Device,1=Interface,2=Endpoint,3=Other,4..31=Reserved
0000            ;        BYTE bType       :2;    // 1=Standard,1=Class,2=Vendor,3=Reserved
0000            ;        BYTE bDirection  :1;    // 0=Host to Device,1=Device to Host
0000            ;        BYTE bRqst;             //
0000            ;                                // 0x00,0x01,0x02 =Clear Feature
0000            ;                                // 0x00,0x01,0x02 =Set Feature
0000            ;                                // 0x80,0x81,0x82 =Get Status
0000            ;                                // 0x00 =Set Address
0000            ;                                // 0x80 =Get Descriptor
0000            ;                                // 0x00 =Set Descriptor
0000            ;                                // 0x80 =Get Configuration
0000            ;                                // 0x81 =Get Interface
0000            ;                                // 0x01 =Set Interface
0000            ;                                // 0x82 =Synch Frame
0000            ;        WORD wValue;            //
0000            ;        WORD wIndex;            //
0000            ;        WORD wLength;           //
0000            ;    }
0000            ;}
0000            
0000            ;*************************************************
0000            ; USB Protocol
0000            USBRqstType                :equ USBEndP0FIFO_0  ;
0000             USBRqstTypeDirection      :equ 80h     ; 1=Device to Host,0=Host to Device
0000            
0000             USBRqstTypeMask           :equ 60h
0000             USBRqstTypeStandard       :equ 00h
0000             USBRqstTypeClass          :equ 20h
0000             USBRqstTypeVendor         :equ 40h
0000             USBRqstTypeReserved       :equ 60h
0000            
0000             USBRqstTargetDevice       :equ 00h
0000             USBRqstTargetInterface    :equ 01h
0000             USBRqstTargetEndPoint     :equ 02h
0000             USBRqstTargetOther        :equ 03h
0000            
0000            USBRqstMessage             :equ USBEndP0FIFO_1  ;
0000             USBRqstGetStatus          :equ 00h     ; bit field: 0x01 =Self powered,0x02 =Remote wakeup
0000             USBRqstClearFeature       :equ 01h
0000             USBRqstReserved02         :equ 02h
0000             USBRqstSetFeature         :equ 03h
0000             USBRqstReserved04         :equ 04h
0000             USBRqstSetAddress         :equ 05h
0000             USBRqstGetDescriptor      :equ 06h
0000             USBRqstSetDescriptor      :equ 07h
0000             USBRqstGetConfiguration   :equ 08h
0000             USBRqstSetConfiguration   :equ 09h
0000             USBRqstGetInterface       :equ 0Ah
0000             USBRqstSetInterface       :equ 0Bh
0000             USBRqstSynchFrame         :equ 0Ch
0000             USBRqstReserved0D         :equ 0Dh
0000            
0000            USBRqstWordValueLo         :equ USBEndP0FIFO_2  ;
0000            USBRqstWordValueHi         :equ USBEndP0FIFO_3  ;
0000            
0000            ;*************************************************
0000            ;
0000            USBDescriptorTypeDevice     :equ 01h
0000            USBDescriptorTypeConfig     :equ 02h
0000            USBDescriptorTypeString     :equ 03h
0000            USBDescriptorTypeInterface  :equ 04h
0000            USBDescriptorTypeEndPoint   :equ 05h
0000            USBDescriptorTypeReserved06 :equ 06h
0000            
0000            ;*************************************************
0000            ;
0000            USBRawProtocolSetup         :equ B4h
0000            USBRawProtocolIn            :equ 96h
0000            USBRawProtocolOut           :equ 87h
0000            USBRawProtocolPort0         :equ C3h
0000            USBRawProtocolPort1         :equ D2h
0000            USBRawProtocolACK           :equ 4Bh
0000            USBRawProtocolNAK           :equ 5Ah
0000            
0000            
0000            ;*************************************************
0000            ; Data Segment (RAM)
0000            ;*************************************************
0000            
0000            ; Program Stack
0000            gbSysProgramStack       :equ 00h    ; [00h-1Fh] Stack 0x20h
0000            gbSysDataStack          :equ 50h    ; [50h-6Fh] Stack 0x20h
0000            gbSysFIFO               :equ 70h    ; [70h-7Fh] EP0 and EP1 FIFO's
0000            
0000            ; Global Interrupt
0000            gbSysInterruptMask      :equ 20h    ; Holds the current interrupt mask
0000            
0000            ; System tickers
0000            gbSysTick1024us         :equ 22h    ; # of 1mSec ticks
0000            gbSysTick1024usRoll     :equ 24h    ; # of 256mSec ticks
0000            
0000            ; USB management data
0000            gbUSBValidRqsts         :equ 25h    ; Count of USB recognized requests
0000                                                ;   Used during debug
0000            gbUSBSendSequence       :equ 26h    ; Buffer send data 0/1 line
0000            gbUSBSendBytes          :equ 27h    ; Buffer bytes left to send
0000            gbUSBSendBuffer         :equ 28h    ; Offset into current buffer
0000            
0000            gbSuspendCount          :equ 30h    ; # of msec bus has been IDLE
0000            
0000            ; General
0000            gbSysEnumerated         :equ 29h    ; Device is enumerated
0000            
0000            ; LED management
0000            gbLEDBrightnessUpdate   :equ 2Bh    ; Semaphore to reset brightness
0000            gbLEDBrightness         :equ 2Ch    ; Current brightness
0000            LED_ON                  :equ 08h    ; P13 is used to indicate Enumeration
0000            
0000            ; Button management
0000            gbButtonDebounce        :equ 2Dh    ; Debounce count down value
0000            gbButtonPushed          :equ 7Ah    ; USBEndP1FIFO +2 (toggles if button was clicked)
0000            Button_Pin              :equ 04h    ; Pin the switch is on, P12
0000            
0000            ;Port management
0000            gbPort0                :equ 2Eh
0000            gbPort1               :equ 2Fh
0000            
0000            ;//$PAGE
0000            ;*************************************************
0000            ; Code Segment (ROM)
0000            ;*************************************************
0000            
0000            ; Vector Table
0000            org 00h
0000 80 15 [05]     jmp main                ; Reset of some type
0002 80 10 [05]     jmp SysUnUsed           ; 128us timer (not used)
0004 80 83 [05]     jmp SysTimer1024usEvent ; 1024us timer
0006 80 E8 [05]     jmp USBEndPoint0Event   ; EP0
0008 80 10 [05]     jmp SysUnUsed           ; EP1 (not used)
000A 80 10 [05]     jmp SysUnUsed           ; Reserved
000C 80 DF [05]     jmp SysGPIOEvent        ; Button
000E 80 10 [05]     jmp SysUnUsed           ; CExt (not used)
0010            
0010            ;*************************************************
0010            ; Unused event
0010            ; Do nothing, restore machine to prior state
0010            ;*************************************************
0010            SysUnUsed: 
0010 2D    [05]     push  a
0011 1A 20 [06]     mov   a,[gbSysInterruptMask]
0013 1E 20 [13]     ipret SysInterrupt
0015            
0015            ;//$PAGE
0015            ;*******************************************************************************
0015            ; main()
0015            ; @func Entry point after PowerOn, WatchDog timeout or WakeUp from sleeping.
0015            ; @comm Never returns
0015            ;*******************************************************************************
0015            main:
0015                ; This portion of Main is only executed after a RESET (Power-On or USB)
0015                ; Setup data stack in high order RAM, just below EP0 FIFO
0015                ; It will grow down from here
0015 19 70 [04]     mov  a,70h      ; USBEndP0FIFO
0017 30    [05]     swap a,dsp
0018            
0018                ; Initialize both Ports high 
0018 19 FF [04]     mov  a,FFh
001A 2A 00 [05]     iowr SysPort0   ; Port 0 Data reg
001C 2A 01 [05]     iowr SysPort1   ; Port 1 Data reg 
001E 31 2E [05]     mov [gbPort0],a     ;neu
0020 31 2F [05]     mov [gbPort1],a
0022                                ;   1 on P13 is needed to make sure enumerate LED is off
0022                                ;   1 on any port that needs to be an input
0022                ; Enable Pullups (0=enable)
0022 19 00 [04]     mov  a,0
0024 2A 08 [05]     iowr SysPort0PullUp
0026 19 04 [04]     mov  a,Button_Pin
0028 2A 09 [05]     iowr SysPort1PullUp     ; 1 on P12 is needed to make sure GPIO interrupt
002A                                        ;   occurs on LOW to HIGH transistion. This
002A                                        ;   disables it's pull up
002A                           
002A                ; Enable or disable interrupts on appropriate pins
002A 19 00 [04]     mov  a,0
002C 2A 04 [05]     iowr SysPort0IntEnable     ; All pins irq's are disabled on Port 0
002E 19 04 [04]     mov  a,Button_Pin              
0030 2A 05 [05]     iowr SysPort1IntEnable     ; Enable P12, the button pin.
0032                                           ; No interrupts will occur until the device
0032                                           ;   is enumerated. Then GPIO's will be enabled and
0032                                           ;   we will allow P12 to generate interrupts
0032            
0032                ; Initialize timers
0032 19 00 [04]     mov  a,0
0034 31 22 [05]     mov  [gbSysTick1024us],a
0036 31 24 [05]     mov  [gbSysTick1024usRoll],a
0038            
0038                ; Initialize USB variables
0038 19 00 [04]     mov  a,0
003A 31 25 [05]     mov  [gbUSBValidRqsts],a    ; No valid requests yet
003C 31 26 [05]     mov  [gbUSBSendSequence],a  ; Start with a 0
003E 31 29 [05]     mov  [gbSysEnumerated],a    ; Not enumerated
0040            
0040                ; Initialize LED
0040 19 01 [04]     mov  a,1     ; flag it for an update
0042 31 2B [05]     mov  [gbLEDBrightnessUpdate],a
0044 19 FF [04]     mov  a,FFh   ; set for maximum brightness
0046 31 2C [05]     mov  [gbLEDBrightness],a
0048            
0048                ; Initialized Button
0048 19 00 [04]     mov  a,0
004A 31 7A [05]     mov  [gbButtonPushed],a     ; Initial state of 0, no button pushed
004C            
004C                ; Initialize variables
004C 19 00 [04]     mov a,0
004E 31 27 [05]     mov [gbUSBSendBytes],a      ; No bytes to send in FIFO buffers
0050 31 30 [05]     mov [gbSuspendCount],a      ; Reset bus activity to 0
0052 31 2D [05]     mov [gbButtonDebounce],a    ; We are not debouncing
0054            
0054                ; Set interrupt mask
0054 19 0C [04]     mov  a,SysIntTimer1024us  | SysIntUSBEndP0 
0056 31 20 [05]     mov  [gbSysInterruptMask],a
0058            
0058                ;*********************************************
0058              MainLoop:
0058                ; Enable interrupts to current mask
0058 1A 20 [06]     mov  a,[gbSysInterruptMask]
005A 2A 20 [05]     iowr SysInterrupt
005C            
005C                ;*************************
005C                ; do nothing until we are enumerated
005C 19 00 [04]     mov  a,0
005E 17 29 [06]     cmp  a,[gbSysEnumerated]
0060 A0 58 [05]     jz   MainLoop                   ; Not enumerated, loop
0062            
0062            
0062                ; Ah! We're enumerated, lets do the rest of the loop
0062                ;*************************
0062            
0062                ; Write a 0 to the LED on P13 to turn it on
0062 19 F7 [04]     mov a,F7h
0064 31 2F [05]     mov [gbPort1],a
0066            
0066            Loop2:
0066                ; Enable interrupts to current mask
0066 1A 20 [06]     mov  a,[gbSysInterruptMask]
0068 2A 20 [05]     iowr SysInterrupt
006A            
006A                ;*************************
006A                ; do nothing until we are enumerated
006A 19 00 [04]     mov  a,0
006C 17 29 [06]     cmp  a,[gbSysEnumerated]
006E A0 66 [05]     jz   Loop2                  ; Not enumerated, loop
0070            
0070                ; Wait 10 milliseconds
0070 19 0A [04]     mov  a,10
0072 94 3A [10]     call SysDelayMS
0074            
0074                ;*************************
0074                ; Read temperature
0074 93 1B [10]     call ThermReadTemperature
0076            
0076                ;*************************
0076                ; Update brightness?
0076                ; mov  a,0
0076 17 2B [06]     cmp  a,[gbLEDBrightnessUpdate]
0078 A0 80 [05]     jz   MainLoopNoLEDUpdate        ; No, branch
007A            
007A                ; Yes, update the LED brightness
007A                ; Reset the LED update flag
007A                ; mov a,0h
007A 31 2B [05]     mov  [gbLEDBrightnessUpdate],a
007C            
007C                ; Set new brightness
007C 1A 2C [06]     mov  a,[gbLEDBrightness]
007E 2A 3B [05]     iowr SysPort1ISinkPin3
0080            
0080                ; Fall through to here in any case
0080              MainLoopNoLEDUpdate:
0080            
0080                ; Loop
0080 80 66 [05]     jmp  Loop2  ;neu, alt: MainLoop
0082                ;*********************************************
0082            
0082 00    [08]     halt
0083                ; Oops! We should never get here
0083            
0083            
0083            ;********************************************************
0083            ; SysTimer1024usEvent()
0083            ; @func Timer interrupt event ocurring every 1.024 mSec
0083            ;       using 6Mhz crystal.
0083            ;********************************************************
0083            SysTimer1024usEvent:
0083            
0083                ; Save accumulator
0083 2D    [05]     push a
0084            
0084                ; Clear watchdog timer
0084                ; Clearing it here effectively disables the timer
0084 2A 21 [05]     iowr SysWatchDog
0086            
0086              STPortsRefresh:   ;neu
0086 1A 2E [06]     mov  a,[gbPort0]
0088 2A 00 [05]     iowr SysPort0
008A 1A 2F [06]     mov  a,[gbPort1]
008C 2A 01 [05]     iowr SysPort1
008E            
008E                ; Keep track of length of any IDLE conditions (No bus activity)
008E 29 13 [05]     iord USBControl                    ; Read the USB Status and Control Reg
0090 10 01 [04]     and a,01h                          ; Check bit 0
0092 16 00 [04]     cmp a,0h
0094 A0 A2 [05]     jz Inc_Counter                     ; Hmm! No activity. Branch and keep track of it.
0096 29 13 [05]     iord USBControl                    ; Ah! There was activity, 
0098                                                   ;  clear the bus activity bit
0098 10 FE [04]     and a,0feh
009A 2A 13 [05]     iowr USBControl
009C 19 00 [04]     mov a,0                            ; Clear the suspend counter
009E 31 30 [05]     mov [gbSuspendCount],a
00A0 80 B5 [05]     jmp Suspend_End
00A2            
00A2              Inc_Counter:                         ; Monitor the IDLE count
00A2 1A 30 [06]     mov a,[gbSuspendCount]             ; Get # of mSec we have been IDLE
00A4 21    [04]     inc a                              ; Increment the count
00A5 31 30 [05]     mov [gbSuspendCount],a              
00A7 16 03 [04]     cmp a,03h                          ; Has it been 3msec yet?
00A9 B0 B5 [05]     jnz Suspend_End                    ; Not yet, branch
00AB 19 00 [04]     mov a,0h                           ; Yes, clear the suspend counter
00AD 31 30 [05]     mov [gbSuspendCount],a
00AF 29 FF [05]     iord SysStatus
00B1 0D 08 [04]     or a,08h                           ; Set the suspend bit to cause a suspend
00B3 2A FF [05]     iowr SysStatus                     ; We will enter the suspend state during
00B5                                                   ;   the next instruction.   
00B5            
00B5              Suspend_End:
00B5               ; Increment the 1024 usec counter and check for rollover
00B5 23 22 [07]     inc  [gbSysTick1024us]
00B7 B0 BD [05]     jnz  STimerNo1024usRoll     ; No
00B9            
00B9                ; Clear rollover
00B9 19 00 [04]     mov  a,0
00BB 31 24 [05]     mov  [gbSysTick1024usRoll],a
00BD            
00BD              STimerNo1024usRoll:
00BD                ; Are we counting down a button debounce
00BD 19 00 [04]     mov  a,0
00BF 17 2D [06]     cmp  a,[gbButtonDebounce]
00C1 A0 DB [05]     jz   STimerNoDebounce       ; Not debouncing, branch
00C3            
00C3                ; Yes, we're debouncing. Let's see if we are timed out.
00C3 27 2D [07]     dec  [gbButtonDebounce]
00C5 19 00 [04]     mov  a,0
00C7 17 2D [06]     cmp a,[gbButtonDebounce]
00C9            
00C9                ; has debounce timed out?
00C9 B0 DB [05]     jnz STimerNoDebounce        ; No, still debouncing, branch.
00CB            
00CB                ; The debounce timer has timed out
00CB                ; check if the button pin is at a 1. If not, the button is either still
00CB                ;    bouncing or still pushed
00CB 29 01 [05]     iord SysPort1              ; check the port the button is on
00CD 10 04 [04]     and a,Button_Pin           ; check the pin
00CF B0 D7 [05]     jnz STimerDebounceOver     ; branch if it is not pushed ; mrr
00D1            
00D1                ; Reset debounce since the button is not yet released or is bouncing
00D1 19 64 [04]     mov  a,100
00D3 31 2D [05]     mov  [gbButtonDebounce],a
00D5 B0 DB [05]     jnz STimerNoDebounce       ; continue waiting for debounce to end
00D7            
00D7              STimerDebounceOver:
00D7                ; it's really ready!
00D7                ; Toggle the button state flag to let the Windows app know that
00D7                ;   the button has been pushed.
00D7 19 01 [04]     mov  a,1
00D9 37 7A [07]     xor  [gbButtonPushed],a
00DB            
00DB                ; Debounce must be over
00DB              STimerNoDebounce:
00DB                ; Enable interrupts and return
00DB 1A 20 [06]     mov  a,[gbSysInterruptMask]
00DD 1E 20 [13]     ipret SysInterrupt
00DF            
00DF            ;//$PAGE
00DF            ;********************************************************
00DF            ; SysGPIOEvent()
00DF            ; @func General purpose port event
00DF            ; @comm Which pin?
00DF            ;********************************************************
00DF            SysGPIOEvent:
00DF            
00DF                ; Save accumulator
00DF 2D    [05]     push a
00E0            
00E0                ; Reset debounce any time we are here
00E0 19 64 [04]     mov  a,100
00E2 31 2D [05]     mov  [gbButtonDebounce],a
00E4            
00E4              SysGPIOButtonDebouncing:
00E4                ; Enable interrupts and return
00E4 1A 20 [06]     mov  a,[gbSysInterruptMask]
00E6 1E 20 [13]     ipret SysInterrupt
00E8            
00E8            
00E8            ;*******************************************************************************
00E8            ;
00E8            ;    This section of code responds to activity on End Point 0 and determines
00E8            ;    what needs to be done.
00E8            ;
00E8            ;*******************************************************************************
00E8            
00E8            ;//$PAGE
00E8            ;********************************************************
00E8            ; USBEndPoint0Event()
00E8            ; @func End Point zero USB event.
00E8            ; @comm Default end point.
00E8            ;********************************************************
00E8            USBEndPoint0Event:
00E8            
00E8                ; This code checks to see what type of packet was received 
00E8                ;   (Setup, Out, or In) and jumps to the correct routine to decode the 
00E8                ;   specifics. After the code to which the jump points is through, it jumps
00E8                ;   back to USBEventEP0End.
00E8            
00E8                ; Save accumulator
00E8 2D    [05]     push a
00E9            
00E9                ; Is this a SETUP packet?
00E9 29 14 [05]     iord USBEndP0RxStatus
00EB 10 01 [04]     and  a,USBEndP0RxSetup      ; Check the setup bit
00ED B0 FB [05]     jnz  USBEventEP0_SETUP      ; Yes it's a setup, branch
00EF            
00EF                ; Not a setup, is it an OUT packet?
00EF               ;iord USBEndP0RxStatus
00EF               ;and  a,USBEndP0RxOut
00EF               ;jnz  USBEventEP0_OUT
00EF            
00EF                ; Not an OUT packet, is it an IN packet?
00EF               ;iord USBEndP0RxStatus
00EF               ;and  a,USBEndP0RxIn
00EF               ;jnz  USBEventEP0_IN
00EF            
00EF              USBEventEP0_IN:
00EF              USBEventEP0_OUT:
00EF            
00EF              USBEventEP0End:
00EF                ; OK. We're done with the packet.
00EF                ;   Let's enable interrupts and return
00EF 1A 20 [06]     mov  a,[gbSysInterruptMask]
00F1 1E 20 [13]     ipret SysInterrupt    ; done with EP0 irq service routine
00F3            
00F3              USBEventEP0Stall:
00F3                ; Stall any subsequent IN's or OUT's until the
00F3                ;       stall bit (bit 5) is cleard by an I/O write to
00F3                ;       the  USB End Point 0 TX Configuration Register (0x10)
00F3                ;       or any SETUP is received.
00F3 29 10 [05]     iord USBEndP0TxConfig
00F5 0D 20 [04]     or   a,USBEndP0TxStall
00F7 2A 10 [05]     iowr USBEndP0TxConfig
00F9            
00F9                ; OK. We've set the stall condition for Endpoint 0.
00F9                ;   Now let's complete the routine.
00F9 80 EF [05]     jmp  USBEventEP0End
00FB            
00FB            ;*******************************************************************************
00FB            ; 
00FB            ;    We know we have received a Setup token. Now we need to parse it to
00FB            ;    determine what command it is.
00FB            ;
00FB            ;*******************************************************************************
00FB            
00FB            
00FB            ;//$PAGE
00FB            ;*******************************************************************************
00FB            ; USBEventEP0_SETUP()
00FB            ; @func End point event SETUP packet handler.
00FB            ; @devnote Runs in interrupt enabled context.
00FB            ;********************************************************
00FB            USBEventEP0_SETUP:
00FB                ; Well, we have a SETUP packet. Let's find out what to do.
00FB 1A 20 [06]     mov A,[gbSysInterruptMask]
00FD 2A 20 [05]     iowr SysInterrupt
00FF            
00FF                ; If we are here and are and we are processing a previous Setup, 
00FF                ;  we need to abort the processing of the previous Setup
00FF 1F    [04]         XPAGE
0100 19 00 [04]     mov  a,0    ; Clear any indication that we have bytes left to transfer
0102 31 27 [05]     mov [gbUSBSendBytes],a
0104             
0104                ; Clear EP0 RxReg (including the Setup flag)
0104                ; The Data toggle bit remains unchanged, however.
0104 19 00 [04]     mov  a,0
0106 2A 14 [05]     iowr USBEndP0RxStatus
0108            
0108                ;*********************************************
0108                ; Setup Event
0108                ;*********************************************
0108            
0108                ; Check the request type and branch to the correct location to handle it.
0108 1A 70 [06]     mov  a,[USBEndP0FIFO_0]
010A            
010A              USBEventEP0SetupTargetDeviceOUT:
010A                ; Target Device?
010A 16 00 [04]     cmp  a,USBRqstTargetDevice
010C A1 2C [05]     jz   USBEventEP0SetupIsSetAddress   ; Yes
010E            
010E              USBEventEP0SetupTargetInterfaceOUT:
010E 16 01 [04]     cmp  a,USBRqstTargetInterface
0110 A0 F3 [05]     jz   USBEventEP0Stall               ; Yes. Oops! We don't have an interface.
0112            
0112              USBEventEP0SetupTargetEndpointOUT:
0112 16 02 [04]     cmp  a,USBRqstTargetEndPoint
0114 A0 F3 [05]     jz   USBEventEP0Stall               ; Yes
0116            
0116              USBEventEP0SetupTargetDeviceIN:
0116 16 80 [04]     cmp  a,USBRqstTargetDevice | USBRqstTypeDirection
0118 A1 5E [05]     jz   USBEventEP0SetupGetDescriptor  ; Yes
011A            
011A              USBEventEP0SetupTargetInterfaceIN:
011A 16 81 [04]     cmp  a,USBRqstTargetInterface | USBRqstTypeDirection
011C A0 F3 [05]     jz   USBEventEP0Stall               ; Yes Oops! We don't have an interface.
011E            
011E              USBEventEP0SetupTargetEndpointIN:
011E 16 82 [04]     cmp  a,USBRqstTargetEndPoint | USBRqstTypeDirection
0120 A0 F3 [05]     jz   USBEventEP0Stall               ; Yes
0122            
0122                ; Vendor specific commands
0122              USBEventEP0SetupTargetVendorIN_OUT:
0122                ; Check request (IN packet OK, OUT packet ERR)
0122 1A 70 [06]     mov  a,[USBEndP0FIFO_0]
0124 10 C2 [04]     and  a,USBRqstTypeVendor | USBRqstTargetEndPoint | USBRqstTypeDirection
0126 16 C2 [04]     cmp  a,USBRqstTypeVendor | USBRqstTargetEndPoint | USBRqstTypeDirection
0128 A2 87 [05]     jz   USBEventEP0VendorRqst
012A            
012A                ; Unsupported request !!!
012A 80 F3 [05]     jmp  USBEventEP0Stall               ; Oops! We don't support whatever
012C                                                    ;   request was made.
012C            
012C            
012C            ;//$PAGE
012C            ;********************************************************
012C            ; USBEventEP0SetupIsSet()
012C            ; @func End point event SETUP to set address.
012C            ; @devnote Runs in interrupt enabled context.
012C            ;********************************************************
012C            USBEventEP0SetupIsSetAddress:
012C            
012C                ; Set device address?
012C 1A 71 [06]     mov  a,[USBRqstMessage]
012E 16 05 [04]     cmp  a,USBRqstSetAddress
0130 A1 42 [05]     jz   USBEventEP0SetupSetAddress         ; Yes
0132            
0132              USBEventEP0SetupIsSetConfig:
0132                ; Set device configuration?
0132 1A 71 [06]     mov  a,[USBEndP0FIFO_1]
0134 16 09 [04]     cmp  a,USBRqstSetConfiguration
0136 A1 4C [05]     jz   USBEventEP0SetupSetConfig          ; Yes
0138            
0138                ; Unsupported set request !!!
0138 80 F3 [05]     jmp  USBEventEP0Stall                   ; No. Stall
013A            
013A              ;USBEventEP0SetupIsGetDescriptor:
013A 1A 71 [06]     mov  a,[USBRqstMessage]
013C 16 06 [04]     cmp  a,USBRqstGetDescriptor
013E A1 5E [05]     jz   USBEventEP0SetupGetDescriptor      ; Yes
0140            
0140                ; Unsupported get request !!!
0140 80 F3 [05]     jmp  USBEventEP0Stall                   ; No
0142            
0142            ;********************************************************
0142            ; USBEventEP0SetupSetAddress()
0142            ; @func End point zero event SETUP to set address.
0142            ; @devnote Runs in interrupt enabled context.
0142            ; @comm
0142            ; The status token of the SetAddress is an IN. So, we send status manually.
0142            ;********************************************************
0142            USBEventEP0SetupSetAddress:
0142            
0142                ; Send ACK
0142 92 6E [10]     call USBSendACK
0144                ; Now that we have been acknowleged, we actually set the address.
0144                ; This is different from all other commands which execute first
0144                ;   and then acknowlege (_________________)
0144            
0144                ; Remember this
0144 23 25 [07]     inc [gbUSBValidRqsts]
0146            
0146                ; Set Address
0146 1A 72 [06]     mov  a,[USBRqstWordValueLo]
0148 2A 12 [05]     iowr USBDeviceAddress
014A            
014A                ; Done
014A 80 EF [05]     jmp  USBEventEP0End
014C            
014C            ;********************************************************
014C            ; USBEventEP0SetupSetConfig()
014C            ; @func End point zero event SETUP to Set Configuration.
014C            ; @devnote Runs in interrupt enabled context.
014C            ; 1
014C            ;  set enumerated (gbSysEnumerated) state, 
014C            ;  enable GPIO (and EP1, if appropriate)
014C            ;  Enable P0 and P1
014C            ; 0
014C            ;  Reset enumerated (gbSysEnumerated) state, 
014C            ;  Turn off LED
014C            ;  Reset variables
014C            ;  Disable GPIO and EP1
014C            ;  Disable dallas chip and P0 and P1
014C            ;********************************************************
014C            USBEventEP0SetupSetConfig:
014C            
014C                ; Enumerated !
014C 19 01 [04]     mov  a,01h
014E 31 29 [05]     mov  [gbSysEnumerated],a
0150            
0150                ; Initialize thermometer
0150 92 F3 [10]     call ThermInitialize
0152            
0152                ; Enable button interrupt on port 1.
0152                ;   Actually, this has already been done in main().
0152 19 04 [04]     mov  a,04h
0154 2A 05 [05]     iowr SysPort1IntEnable
0156            
0156                ; enable all appropriate irq's
0156 19 4C [04]     mov  a,SysIntTimer1024us | SysIntGPIO | SysIntUSBEndP0
0158 31 20 [05]     mov  [gbSysInterruptMask],a
015A            
015A                ; Send ACK
015A 92 6E [10]     call USBSendACK
015C 80 EF [05]     jmp  USBEventEP0End
015E            
015E            ;//$PAGE
015E            ;********************************************************
015E            ; USBEventEP0SetupGetDescriptor()
015E            ; @func End point zero event SETUP to Get Descriptor.
015E            ; @devnote Runs in interrupt enabled context.
015E            ;********************************************************
015E            USBEventEP0SetupGetDescriptor:
015E            
015E                ; Get descriptor type
015E 1A 73 [06]     mov  a,[USBRqstWordValueHi]
0160            
0160              USBEventEP0SetupGetDescriptorDevice:
0160                ; Device Descriptor?
0160 16 01 [04]     cmp  a,USBDescriptorTypeDevice
0162 B1 74 [05]     jnz  USBEventEP0SetupGetDescriptorConfig    ; No
0164            
0164                ; Remember this
0164 23 25 [07]     inc [gbUSBValidRqsts]
0166            
0166                ;*********************************************
0166                ; Get Device Descriptor Event
0166                ;*********************************************
0166                ; Descriptor pointer
0166 19 00 [04]     mov  a,(USBDeviceDescription -USBSendROMBufferBase)
0168 31 28 [05]     mov  [gbUSBSendBuffer],a
016A            
016A                ; Descriptor size
016A 19 12 [04]     mov  a,12h                  ;[USBDeviceDescription]
016C 31 27 [05]     mov  [gbUSBSendBytes],a
016E            
016E                ; Check request size field
016E 92 02 [10]     call USBSendDescriptorCheckLength
0170            
0170                ; Send buffer
0170 92 13 [10]     call USBSendROMBuffer
0172 80 EF [05]     jmp  USBEventEP0End
0174            
0174              USBEventEP0SetupGetDescriptorConfig:
0174                ; Configuration Descriptor?
0174 16 02 [04]     cmp  a,USBDescriptorTypeConfig
0176 B1 8C [05]     jnz  USBEventEP0SetupGetDescriptorString    ; No
0178            
0178                ; Remember this
0178 23 25 [07]     inc [gbUSBValidRqsts]
017A            
017A                ;*********************************************
017A                ; Get Configuration Descriptor Event
017A                ;*********************************************
017A                ; Descriptor pointer
017A 19 12 [04]     mov  a,(USBConfigurationDescription -USBSendROMBufferBase)
017C 31 28 [05]     mov  [gbUSBSendBuffer],a
017E            
017E                ; Descriptor size
017E 19 09 [04]     mov  a,09h                  ;[USBConfigurationDescription]
0180 01 09 [04]     add  a,09h                  ;[USBInterfaceDescription]
0182 01 07 [04]     add  a,07h                  ;[USBEndPointDescriptionInt]
0184 31 27 [05]     mov  [gbUSBSendBytes],a
0186            
0186                ; Check request size field
0186 92 02 [10]     call USBSendDescriptorCheckLength
0188            
0188                ; Send buffer
0188 92 13 [10]     call USBSendROMBuffer
018A 80 EF [05]     jmp  USBEventEP0End
018C            
018C              USBEventEP0SetupGetDescriptorString:
018C                ; Get String Descriptor?
018C 16 03 [04]     cmp  a,USBDescriptorTypeString
018E B1 FE [05]     jnz  USBEventEP0SetupGetDescriptorEnd       ; No
0190            
0190                ;*********************************************
0190                ; Get String Descriptor Event
0190                ;*********************************************
0190            
0190                ; Get string descriptor index
0190 1A 72 [06]     mov  a,[USBRqstWordValueLo]
0192            
0192              USBEventEP0SetupGetDescriptorString0:
0192 16 00 [04]     cmp  a,0h
0194 B1 A4 [05]     jnz  USBEventEP0SetupGetDescriptorString1   ; No
0196            
0196                ;*********************************************
0196                ; Get String Language(s) Descriptor Event
0196                ;*********************************************
0196                ; Descriptor pointer
0196 19 2B [04]     mov  a,(USBStringLanguageDescription -USBSendROMBufferBase)
0198 31 28 [05]     mov  [gbUSBSendBuffer],a
019A            
019A                ; Descriptor size
019A 19 04 [04]     mov  a,4h                   ;[USBStringLanguageDescription]
019C 31 27 [05]     mov  [gbUSBSendBytes],a
019E            
019E                ; Check request size field
019E 92 02 [10]     call USBSendDescriptorCheckLength
01A0            
01A0                ; Send buffer
01A0 92 13 [10]     call USBSendROMBuffer
01A2 80 EF [05]     jmp  USBEventEP0End
01A4            
01A4              USBEventEP0SetupGetDescriptorString1:
01A4 16 01 [04]     cmp  a,1
01A6 B1 B6 [05]     jnz  USBEventEP0SetupGetDescriptorString2   ; No
01A8            
01A8                ;*********************************************
01A8                ; Get String 1 Descriptor Event
01A8                ;*********************************************
01A8                ; Descriptor pointer
01A8 19 2F [04]     mov  a,(USBStringDescription1 -USBSendROMBufferBase)
01AA 31 28 [05]     mov  [gbUSBSendBuffer],a
01AC            
01AC                ; Descriptor size
01AC 19 10 [04]     mov  a,10h                  ;[USBStringDescription1]
01AE 31 27 [05]     mov  [gbUSBSendBytes],a
01B0            
01B0                ; Check request size field
01B0 92 02 [10]     call USBSendDescriptorCheckLength
01B2            
01B2                ; Send buffer
01B2 92 13 [10]     call USBSendROMBuffer
01B4 80 EF [05]     jmp  USBEventEP0End
01B6            
01B6              USBEventEP0SetupGetDescriptorString2:
01B6 16 02 [04]     cmp  a,2
01B8 B1 C8 [05]     jnz  USBEventEP0SetupGetDescriptorString3   ; No
01BA            
01BA                ;*********************************************
01BA                ; Get String 2 Descriptor Event
01BA                ;*********************************************
01BA                ; Descriptor pointer
01BA 19 3F [04]     mov  a,(USBStringDescription2 -USBSendROMBufferBase)
01BC 31 28 [05]     mov  [gbUSBSendBuffer],a
01BE            
01BE                ; Descriptor size
01BE 19 18 [04]     mov  a,18h                  ;[USBStringDescription2]
01C0 31 27 [05]     mov  [gbUSBSendBytes],a
01C2            
01C2                ; Check request size field
01C2 92 02 [10]     call USBSendDescriptorCheckLength
01C4            
01C4                ; Send buffer
01C4 92 13 [10]     call USBSendROMBuffer
01C6 80 EF [05]     jmp  USBEventEP0End
01C8            
01C8              USBEventEP0SetupGetDescriptorString3:
01C8 16 03 [04]     cmp  a,3
01CA B1 DA [05]     jnz  USBEventEP0SetupGetDescriptorString4   ; No
01CC            
01CC                ;*********************************************
01CC                ; Get String 3 Descriptor Event
01CC                ;*********************************************
01CC                ; Descriptor pointer
01CC 19 57 [04]     mov  a,(USBStringDescription3 -USBSendROMBufferBase)
01CE 31 28 [05]     mov  [gbUSBSendBuffer],a
01D0            
01D0                ; Descriptor size
01D0 19 24 [04]     mov  a,24h                  ;[USBStringDescription3]
01D2 31 27 [05]     mov  [gbUSBSendBytes],a
01D4            
01D4                ; Check request size field
01D4 92 02 [10]     call USBSendDescriptorCheckLength
01D6            
01D6                ; Send buffer
01D6 92 13 [10]     call USBSendROMBuffer
01D8 80 EF [05]     jmp  USBEventEP0End
01DA            
01DA              USBEventEP0SetupGetDescriptorString4:
01DA 16 04 [04]     cmp  a,4
01DC B1 EC [05]     jnz  USBEventEP0SetupGetDescriptorString5   ; No
01DE            
01DE                ;*********************************************
01DE                ; Get String 4 Descriptor Event
01DE                ;*********************************************
01DE                ; Descriptor pointer
01DE 19 57 [04]     mov  a,(USBStringDescription4 -USBSendROMBufferBase)
01E0 31 28 [05]     mov  [gbUSBSendBuffer],a
01E2            
01E2                ; Descriptor size
01E2 19 20 [04]     mov  a,20h                  ;[USBStringDescription4]
01E4 31 27 [05]     mov  [gbUSBSendBytes],a
01E6            
01E6                ; Check request size field
01E6 92 02 [10]     call USBSendDescriptorCheckLength
01E8            
01E8                ; Send buffer
01E8 92 13 [10]     call USBSendROMBuffer
01EA 80 EF [05]     jmp  USBEventEP0End
01EC            
01EC              USBEventEP0SetupGetDescriptorString5:
01EC 16 05 [04]     cmp  a,5
01EE B1 FE [05]     jnz  USBEventEP0SetupGetDescriptorEnd       ; No
01F0            
01F0                ;*********************************************
01F0                ; Get String 5 Descriptor Event
01F0                ;*********************************************
01F0                ; Descriptor pointer
01F0 19 77 [04]     mov  a,(USBStringDescription5 -USBSendROMBufferBase)
01F2 31 28 [05]     mov  [gbUSBSendBuffer],a
01F4            
01F4                ; Descriptor size
01F4 19 3C [04]     mov  a,3Ch                  ;[USBStringDescription5]
01F6 31 27 [05]     mov  [gbUSBSendBytes],a
01F8            
01F8                ; Check request size field
01F8 92 02 [10]     call USBSendDescriptorCheckLength
01FA            
01FA                ; Send buffer
01FA 92 13 [10]     call USBSendROMBuffer
01FC 80 EF [05]     jmp  USBEventEP0End
01FE            
01FE              USBEventEP0SetupGetDescriptorEnd:
01FE                ; Unsupported Get request !!!
01FE 20    [04]         NOP
01FF 1F    [04]         XPAGE
0200 80 F3 [05]     jmp  USBEventEP0Stall
0202            
0202            ;//$PAGE
0202            ;********************************************************
0202            ; USBSendDescriptorCheckLength()
0202            ; @func Check and update send length for Get Descriptor
0202            ;       requests on end point 0.
0202            ; @parm BYTE | gbUSBSendBytes | Number of bytes to send.
0202            ;********************************************************
0202            USBSendDescriptorCheckLength:
0202            
0202                ; High byte set? (Assume <255 bytes)
0202 1A 77 [06]     mov  a,[USBEndP0FIFO_7]
0204 16 00 [04]     cmp  a,0
0206 B2 12 [05]     jnz  USBSendDescriptorCheckLengthEnd    ; Yes
0208            
0208                ; Check size
0208 1A 76 [06]     mov  a,[USBEndP0FIFO_6]
020A 17 27 [06]     cmp  a,[gbUSBSendBytes]
020C A2 12 [05]     jz   USBSendDescriptorCheckLengthEnd    ; equal
020E D2 12 [05]     jnc  USBSendDescriptorCheckLengthEnd    ; greater than
0210            
0210                ; New size
0210 31 27 [05]     mov  [gbUSBSendBytes],a
0212            
0212              USBSendDescriptorCheckLengthEnd:
0212 3F    [08]     ret
0213            
0213            ;//$PAGE
0213            ;********************************************************
0213            ; USBSendROMBuffer()
0213            ; @func Send a number of ROM bytes on end point 0.
0213            ; @parm BYTE | gbUSBSendBytes | Number of bytes to send.
0213            ; @parm BYTE | gbUSBSendBuffer | Offset from ROM base
0213            ;       of data to send.
0213            ; @comm assumes IN packets are ignored in the interrupt routine
0213            ; @devnote Enables interrupts
0213            ;********************************************************
0213            USBSendROMBuffer:
0213            
0213                ; Clear flag
0213 19 00 [04]     mov  a,0h
0215 2A 14 [05]     iowr USBEndP0RxStatus
0217            
0217                ; Enable interrupts
0217 1A 20 [06]     mov  a,[gbSysInterruptMask]
0219 10 F7 [04]     and  a,~SysIntUSBEndP0
021B 2A 20 [05]     iowr SysInterrupt
021D            
021D                ; Auto ACK OUT packet (This would be a Status Out)
021D 19 08 [04]     mov  a,USBControlAckStatusData
021F 2A 13 [05]     iowr USBControl
0221            
0221                ; Initialize sequence
0221 19 00 [04]     mov  a,0h
0223 31 26 [05]     mov  [gbUSBSendSequence],a
0225            
0225                ; Send count
0225 1A 27 [06]     mov  a,[gbUSBSendBytes]
0227            
0227            USendROMBufferLoop:
0227                ; One 8-byte chunk or less left?
0227 16 08 [04]     cmp  a,08h
0229 A2 41 [05]     jz   USendROMBufferLoopDone     ; exactly 8 bytes left, branch
022B C2 41 [05]     jc   USendROMBufferLoopDone     ; less than 8 bytes left, branch
022D            
022D                ; more than 8 bytes left, fall through and loop 
022D                ;    until there are 8 bytes or less.
022D                ; Save count
022D 2D    [05]     push a
022E            
022E                ; Send 8 byte chunk
022E 19 08 [04]     mov  a,08h
0230 31 27 [05]     mov  [gbUSBSendBytes],a
0232 92 44 [10]     call _USBSendROMBuffer
0234            
0234                ; Check for OUT packet cancelling send
0234 29 14 [05]     iord USBEndP0RxStatus
0236 10 02 [04]     and  a,USBEndP0RxOut
0238            
0238                ; Restore count
0238 2B    [04]     pop  a
0239            
0239                ; Handle exception: OUT packet cancel send
0239 B2 43 [05]     jnz  USendROMBufferLoopExit     ; Cancelled
023B            
023B                ; Save bytes left
023B 07 08 [04]     sub  a,08h
023D 31 27 [05]     mov  [gbUSBSendBytes],a
023F 82 27 [05]     jmp  USendROMBufferLoop
0241            
0241              USendROMBufferLoopDone:
0241                ; Send last 8 or less bytes
0241 92 44 [10]     call _USBSendROMBuffer
0243            
0243            USendROMBufferLoopExit:
0243 3F    [08]     ret
0244            
0244            ;//$PAGE
0244            ;********************************************************
0244            ; _USBSendROMBuffer()
0244            ; @func Buffer and inialize USB send of up
0244            ;               to 8 bytes of ROM data on end point 0.
0244            ; @comm affects gbUSBSendBytes & gbUSBSendBuffer
0244            ;********************************************************
0244            _USBSendROMBuffer:
0244            
0244                ; Save x
0244 2E    [05]     push x
0245            
0245                ; Initialize
0245 1C 00 [04]     mov  x,0h
0247            
0247              _USendROMBufferLoop:
0247                ; Any more?
0247 19 00 [04]     mov  a,0h
0249 17 27 [06]     cmp  a,[gbUSBSendBytes]
024B A2 5A [05]     jz  _USendROMBufferLoopDone         ; No more
024D 27 27 [07]     dec  [gbUSBSendBytes]
024F            
024F                ; Move bytes to FIFO
024F 1A 28 [06]     mov  a,[gbUSBSendBuffer]
0251 F4 63 [14]     index USBSendROMBufferBase
0253 32 70 [06]     mov  [x +USBEndP0FIFO],a
0255 22    [04]     inc  x
0256            
0256                ; Next byte
0256 23 28 [07]     inc  [gbUSBSendBuffer]
0258 82 47 [05]     jmp _USendROMBufferLoop
025A            
025A              _USendROMBufferLoopDone:
025A                ; Re-enable reception
025A 19 00 [04]     mov  a,0h
025C 2A 14 [05]     iowr USBEndP0RxStatus
025E            
025E                ; Toggle sequence
025E 19 40 [04]     mov  a,USBEndP0TxSequence
0260 37 26 [07]     xor  [gbUSBSendSequence],a
0262            
0262                ; Send bytes
0262 2E    [05]     push x
0263 2B    [04]     pop  a
0264 0E 26 [06]     or   a,[gbUSBSendSequence]
0266 0D 80 [04]     or   a,USBEndP0TxRespond
0268 2A 10 [05]     iowr USBEndP0TxConfig
026A            
026A                ; The FIFO is loaded, go and wait untill it's read
026A 92 78 [10]     call USBSendWaitForComplete
026C            
026C              _USendROMBufferEnd:
026C                ; Restore and exit
026C 2C    [04]     pop  x
026D 3F    [08]     ret
026E            
026E            ;//$PAGE
026E            ;********************************************************
026E            ; USBSendACK()
026E            ; func Respond to a "USB Status In" with a zero byte buffer with 
026E            ;   Sequence field set) on end point 0.
026E            ; Called by SetAddress and SetConfig commands
026E            ;********************************************************
026E            USBSendACK:
026E            
026E                ; Status response to Status In is to send a zero byte packet
026E 19 C0 [04]     mov  a,USBEndP0TxRespond | USBEndP0TxSequence
0270 2A 10 [05]     iowr USBEndP0TxConfig
0272            
0272                ; Enable interrupts
0272 1A 20 [06]     mov  a,[gbSysInterruptMask]
0274 2A 20 [05]     iowr SysInterrupt
0276            
0276                ; Wait for send complete
0276 82 78 [05]     jmp  USBSendWaitForComplete
0278            
0278            ;********************************************************
0278            ; USBSendWaitForComplete()
0278            ; @func Wait for send to complete on end point 0.
0278            ;********************************************************
0278            
0278            ; At some point, either the 0 data will be ACK'd or a SETUP
0278            ;    will come in. 
0278            ; Either event will cause the "Enable Respond
0278            ;    to In Packets" to be reset, and we will fall out of the loop.
0278            ; In either case, an EP0 IRQ will be generated (5.9.2.2 in Cyp
0278            ;    device spec) if EP0 irq is enabled.
0278            
0278            USBSendWaitForComplete:
0278            
0278                ; Poll the send complete bit
0278                ; This will be reset when the data has been sent to the host
0278                ;   and the host has ACK's, or the host has sent another SETUP
0278                ;   which should terminate this activity in any case.
0278 29 10 [05]     iord USBEndP0TxConfig
027A 10 80 [04]     and  a,USBEndP0TxRespond
027C A2 86 [05]     jz   USBSendWaitComplete
027E            
027E                ; Check for OUT packet cancelling send. A STATUS OUT should
027E                ;   terminate any pending IN's. A Setup could also set the Out bit.
027E 29 14 [05]     iord USBEndP0RxStatus
0280 10 02 [04]     and  a,USBEndP0RxOut
0282 B2 86 [05]     jnz  USBSendWaitComplete    ; Cancelled
0284            
0284                ; Keep waiting
0284 82 78 [05]     jmp  USBSendWaitForComplete
0286            
0286              USBSendWaitComplete:
0286 3F    [08]     ret
0287            
0287            ;//$PAGE
0287            ;********************************************************
0287            ; USBEventEP0VendorRqst()
0287            ; @func Vendor request on end point zero.
0287            ; @devnote Runs in interrupt disabled context.
0287            ;********************************************************
0287            USBEventEP0VendorRqst:
0287            
0287                ; Save it
0287 2E    [05]     push x
0288            
0288                ; Check Protocol
0288 1A 71 [06]     mov  a,[USBEndP0FIFO_1]
028A            
028A              USBEventEP0VendorRqstPing:
028A 16 00 [04]     cmp  a,0h
028C B2 90 [05]     jnz  USBEventEP0VendorRqstReadROM       ; No
028E            
028E                ;*********************************************
028E                ; Ping Event
028E                ;*********************************************
028E 82 E0 [05]     jmp  USBEventEP0VendorRqstFinish
0290            
0290              USBEventEP0VendorRqstReadROM:
0290 16 01 [04]     cmp  a,01h
0292 B2 9C [05]     jnz  USBEventEP0VendorRqstReadRAM       ; No
0294            
0294                ;*********************************************
0294                ; Read ROM Event
0294                ;*********************************************
0294 1A 72 [06]     mov  a,[USBEndP0FIFO_2]
0296 F4 63 [14]     index USBSendROMBufferBase
0298 31 71 [05]     mov  [USBEndP0FIFO_1],a
029A 82 E0 [05]     jmp  USBEventEP0VendorRqstFinish
029C            
029C              USBEventEP0VendorRqstReadRAM:
029C 16 02 [04]     cmp  a,02h
029E B2 AA [05]     jnz  USBEventEP0VendorRqstWriteRAM      ; No
02A0            
02A0                ;*********************************************
02A0                ; Read RAM Event
02A0                ;*********************************************
02A0 1A 72 [06]     mov  a,[USBEndP0FIFO_2]
02A2 2D    [05]     push a
02A3 2C    [04]     pop  x
02A4 1B 00 [07]     mov  a,[x +0]
02A6 31 71 [05]     mov  [USBEndP0FIFO_1],a
02A8 82 E0 [05]     jmp  USBEventEP0VendorRqstFinish
02AA            
02AA              USBEventEP0VendorRqstWriteRAM:
02AA 16 03 [04]     cmp  a,3
02AC B2 B8 [05]     jnz  USBEventEP0VendorRqstReadPort      ; No
02AE            
02AE                ;*********************************************
02AE                ; Write RAM Event
02AE                ;*********************************************
02AE 1A 72 [06]     mov  a,[USBEndP0FIFO_2]
02B0 2D    [05]     push a
02B1 2C    [04]     pop  x
02B2 1A 74 [06]     mov  a,[USBEndP0FIFO_4]
02B4 32 00 [06]     mov  [x +0],a
02B6 82 E0 [05]     jmp  USBEventEP0VendorRqstFinish
02B8            
02B8              USBEventEP0VendorRqstReadPort:
02B8 16 04 [04]     cmp  a,04h
02BA B2 CC [05]     jnz  USBEventEP0VendorRqstWritePort     ; No
02BC            
02BC                ;*********************************************
02BC                ; Read Port Event
02BC                ;*********************************************
02BC 1A 72 [06]     mov  a,[USBEndP0FIFO_2]
02BE 16 00 [04]     cmp  a,0h
02C0 B2 C6 [05]     jnz  USBEventEP0VendorRqstReadPort1
02C2            
02C2              USBEventEP0VendorRqstReadPort0:
02C2 29 00 [05]     iord SysPort0
02C4 82 C8 [05]     jmp  USBEventEP0VendorRqstReadPortsDone
02C6            
02C6              USBEventEP0VendorRqstReadPort1:
02C6 29 01 [05]     iord SysPort1
02C8               ;jmp  USBEventEP0VendorRqstReadPortsDone ; redundant, but good practice
02C8            
02C8              USBEventEP0VendorRqstReadPortsDone:
02C8 31 71 [05]     mov  [USBEndP0FIFO_1],a
02CA 82 E0 [05]     jmp  USBEventEP0VendorRqstFinish
02CC            
02CC              USBEventEP0VendorRqstWritePort:
02CC 16 05 [04]     cmp  a,05h
02CE B0 F3 [05]     jnz  USBEventEP0Stall                   ; No
02D0            
02D0                ;*********************************************
02D0                ; Write Port Event
02D0                ;*********************************************
02D0 1A 72 [06]     mov  a,[USBEndP0FIFO_2]
02D2 16 00 [04]     cmp  a,0
02D4 B2 C6 [05]     jnz  USBEventEP0VendorRqstReadPort1
02D6            
02D6              USBEventEP0VendorRqstWritePort0:
02D6 1A 74 [06]     mov  a,[USBEndP0FIFO_4]
02D8 2A 00 [05]     iowr SysPort0
02DA 82 E0 [05]     jmp  USBEventEP0VendorRqstWritePortsDone
02DC            
02DC              USBEventEP0VendorRqstWritePort1:
02DC 1A 74 [06]     mov  a,[USBEndP0FIFO_4]
02DE 2A 01 [05]     iowr SysPort1
02E0               ;jmp  USBEventEP0VendorRqstWritePortsDone ; redundant, but good practice
02E0            
02E0              USBEventEP0VendorRqstWritePortsDone:
02E0               ;jmp  USBEventEP0VendorRqstFinish ; redundant, but good practice
02E0            
02E0              USBEventEP0VendorRqstFinish:
02E0            
02E0                ; Protocol ACK
02E0 19 42 [04]     mov  a,42h
02E2 31 70 [05]     mov  [USBEndP0FIFO_0],a
02E4            
02E4                ; Auto ACK OUT packet
02E4 19 08 [04]     mov  a,USBControlAckStatusData
02E6 2A 13 [05]     iowr USBControl
02E8            
02E8                ; Send bytes as Data1
02E8 19 08 [04]     mov  a,8
02EA 0D 40 [04]     or   a,USBEndP0TxSequence
02EC 0D 80 [04]     or   a,USBEndP0TxRespond
02EE 2A 10 [05]     iowr USBEndP0TxConfig
02F0            
02F0               ;call USBSendWaitForComplete
02F0            
02F0                ; Restore it
02F0 2C    [04]     pop  x
02F1            
02F1                ; Return
02F1 80 EF [05]     jmp  USBEventEP0End
02F3            
02F3            ;*****************************
02F3            ;//$PAGE
02F3            ;; DS1620a.asm - DS1620 High Reolution Temperature Measurement Sensor
02F3            
02F3            ;; DS1620a.inc - DS1620 High Reolution Temperature Measurement Sensor
02F3            ;;******************************************************************************
02F3            
02F3            
02F3            ; DS1620 Control register
02F3            ThermControlOneShot :equ 01h    ;
02F3            ThermControlCPUUse  :equ 02h    ; 1=data clock,0=Clock line signals start conversion
02F3            ThermControlNVB     :equ 10h    ; Nonvolatile Memory Busy flag (up to 10ms)
02F3            ThermControlDone    :equ 80h    ;
02F3            ThermControlFlags   :equ 60h    ; THF and TLF { Temperature High Flag (THF) and Temperature Low Flag (TLF) }
02F3            
02F3            ; DS1620 Protocol
02F3            ThermRead           :equ A0h
02F3            
02F3            ThermTempRead       :equ AAh
02F3            ThermConvertStart   :equ EEh
02F3            ThermConvertStop    :equ 22h
02F3            ThermTempHighWrite  :equ 01h
02F3            ThermTempLowWrite   :equ 02h
02F3            ThermTempHighRead   :equ A1h    ;ThermTempHighWrite OR ThermRead
02F3            ThermTempLowRead    :equ A2h    ;ThermTempLowWrite  OR ThermRead
02F3            ThermConfigWrite    :equ 0Ch
02F3            ThermConfigRead     :equ ACh    ;ThermConfigWrite OR ThermRead
02F3            ThermCounterRead    :equ A0h    ;00h              OR ThermRead
02F3            ThermCounterLoad    :equ 41h    ;undocumented ???
02F3            ThermSlopeRead      :equ A9h
02F3            
02F3            
02F3            
02F3            ;
02F3            ThermPort                  :equ 00h     ; SysPort0
02F3            ThermMaskBits              :equ 07h     ;
02F3            ThermData                  :equ 01h     ;
02F3            ThermClock                 :equ 02h     ;
02F3            ThermReset                 :equ 04h     ;
02F3            
02F3            gbThermProtocol            :equ 30h     ;
02F3            gbThermPortValue           :equ 31h     ;
02F3            gbThermPortMirror          :equ 32h     ;
02F3            gbThermTempRead            :equ 33h     ;
02F3            gbThermTempRead2           :equ 34h     ;
02F3            gbThermTempLast            :equ 78h     ;USBEndP1FIFO
02F3            gbThermTempLast2           :equ 79h     ;USBEndP1FIFO +1
02F3            
02F3            ;//$PAGE
02F3            ;*******************************************************************************
02F3            ; ThermInitialize()
02F3            ; @func Initialize the thermometer to continuous mode.
02F3            ;*******************************************************************************
02F3            ThermInitialize:
02F3            
02F3                ; Standalone mode
02F3 19 AC [04]     mov  a,ThermConfigRead
02F5 93 5E [10]     call ThermPortRead
02F7            
02F7                ; Check mode
02F7 1A 31 [06]     mov  a,[gbThermPortValue]
02F9 10 03 [04]     and  a,ThermControlOneShot | ThermControlCPUUse
02FB 16 02 [04]     cmp  a,ThermControlCPUUse
02FD A3 10 [05]     jz   ThermInitDone
02FF            
02FF                ; Set mode
02FF 1F    [04]         XPAGE
0300 1A 31 [06]     mov  a,[gbThermPortValue]
0302 10 FC [04]     and  a,~(ThermControlOneShot | ThermControlCPUUse)
0304 0D 0A [04]     or   a,ThermControlCPUUse | 08h ; set reserved bit
0306 31 31 [05]     mov  [gbThermPortValue],a
0308            
0308                ; Write it out
0308 19 0C [04]     mov  a,ThermConfigWrite
030A 93 53 [10]     call ThermPortWrite
030C            
030C                ; Wait 10 milliseconds
030C 19 0A [04]     mov  a,10
030E 94 3A [10]     call SysDelayMS
0310            
0310              ThermInitDone:
0310                ; Start conversion
0310 19 EE [04]     mov  a,ThermConvertStart
0312 31 30 [05]     mov  [gbThermProtocol],a
0314 93 36 [10]     call ThermPortResetHigh
0316 93 6D [10]     call ThermPortProtocolWrite
0318 93 41 [10]     call ThermPortResetLow
031A            
031A 3F    [08]     ret
031B            
031B            ;//$PAGE
031B            ;*******************************************************************************
031B            ; ThermReadTemperature()
031B            ; @func Read the current temperature.
031B            ;*******************************************************************************
031B            ThermReadTemperature:
031B            
031B                ; Initialize results
031B 19 00 [04]     mov  a,0
031D 31 33 [05]     mov  [gbThermTempRead],a
031F 31 34 [05]     mov  [gbThermTempRead2],a
0321            
0321                ; Read Temperature request
0321 19 AA [04]     mov  a,ThermTempRead
0323 31 30 [05]     mov  [gbThermProtocol],a
0325            
0325                ; Get temperature
0325 93 36 [10]     call ThermPortResetHigh
0327 93 6D [10]     call ThermPortProtocolWrite
0329 93 7A [10]     call ThermPortReadTemperature
032B 93 41 [10]     call ThermPortResetLow
032D            
032D                ; Save results
032D 1A 33 [06]     mov  a,[gbThermTempRead]
032F 31 78 [05]     mov  [gbThermTempLast],a
0331 1A 34 [06]     mov  a,[gbThermTempRead2]
0333 31 79 [05]     mov  [gbThermTempLast2],a
0335            
0335 3F    [08]     ret
0336            
0336            ;//$PAGE
0336            ;*******************************************************************************
0336            ; ThermPortResetHigh()
0336            ; @func .
0336            ;*******************************************************************************
0336            ThermPortResetHigh:
0336            
0336                ; Initialize mirror
0336 29 00 [05]     iord [ThermPort]
0338 31 32 [05]     mov  [gbThermPortMirror],a
033A            
033A                ; ThermReset =1;
033A 0D 04 [04]     or   a,ThermReset
033C 31 32 [05]     mov  [gbThermPortMirror],a
033E 2A 00 [05]     iowr ThermPort
0340 3F    [08]     ret
0341            
0341            ;*******************************************************************************
0341            ; ThermPortResetLow()
0341            ; @func .
0341            ;*******************************************************************************
0341            ThermPortResetLow:
0341                ; ThermReset =0;
0341 1A 32 [06]     mov  a,[gbThermPortMirror]
0343 10 FB [04]     and  a,~ThermReset
0345 2A 00 [05]     iowr ThermPort
0347 3F    [08]     ret
0348            
0348            ;*******************************************************************************
0348            ; ThermWaitForDone()
0348            ; @func Wait for indication of temperature conversion complete.
0348            ;*******************************************************************************
0348            ThermWaitForDone:
0348            
0348                ; Read config
0348 19 AC [04]     mov  a,ThermConfigRead
034A 93 5E [10]     call ThermPortRead
034C            
034C                ; Test flag
034C 1A 31 [06]     mov  a,[gbThermPortValue]
034E 10 80 [04]     and  a,ThermControlDone
0350 A3 48 [05]     jz   ThermWaitForDone
0352 3F    [08]     ret
0353            
0353            ;*******************************************************************************
0353            ; ThermPortWrite()
0353            ; @func Write protocol byte and value byte.
0353            ; @parm byte | A | Protocol to send.
0353            ;*******************************************************************************
0353            ThermPortWrite:
0353            
0353                ; Save input
0353 31 30 [05]     mov  [gbThermProtocol],a
0355            
0355 93 36 [10]     call ThermPortResetHigh
0357 93 6D [10]     call ThermPortProtocolWrite
0359 94 03 [10]     call ThermPortWrite8Bits
035B 93 41 [10]     call ThermPortResetLow
035D 3F    [08]     ret
035E            
035E            ;*******************************************************************************
035E            ; ThermPortRead()
035E            ; @func Write protocol byte and read value byte into gbThermPortValue.
035E            ; @parm byte | A | Protocol to send.
035E            ;*******************************************************************************
035E            ThermPortRead:
035E            
035E                ; Save input
035E 31 30 [05]     mov  [gbThermProtocol],a
0360            
0360                ; Initialize results
0360 19 00 [04]     mov  a,0
0362 31 31 [05]     mov  [gbThermPortValue],a
0364            
0364 93 36 [10]     call ThermPortResetHigh
0366 93 6D [10]     call ThermPortProtocolWrite
0368 93 CF [10]     call ThermPortRead8Bits
036A 93 41 [10]     call ThermPortResetLow
036C 3F    [08]     ret
036D            
036D            ;*******************************************************************************
036D            ; ThermPortProtocolWrite()
036D            ; @func .
036D            ; @parm BYTE | gbThermProtocol | Protocol value.
036D            ;*******************************************************************************
036D            ThermPortProtocolWrite:
036D            
036D 1A 31 [06]     mov  a,[gbThermPortValue]
036F 2D    [05]     push a
0370 1A 30 [06]     mov  a,[gbThermProtocol]
0372 31 31 [05]     mov  [gbThermPortValue],a
0374 94 03 [10]     call ThermPortWrite8Bits
0376 2B    [04]     pop  a
0377 31 31 [05]     mov  [gbThermPortValue],a
0379            
0379 3F    [08]     ret
037A            
037A            ;//$PAGE
037A            ;*******************************************************************************
037A            ; ThermPortReadTemperature()
037A            ; @func .
037A            ; @parm BYTE | gbThermTempRead | Returned read temperature (low bits).
037A            ; @parm BYTE | gbThermTempRead2 | Returned read temperature (high bit).
037A            ;*******************************************************************************
037A            ThermPortReadTemperature:
037A            
037A                ; Setup bitmask
037A 19 01 [04]     mov  a,1
037C 2D    [05]     push a
037D 2C    [04]     pop  x
037E            
037E 19 08 [04]     mov  a,8
0380              ThermPortTempReadLoop:
0380 2D    [05]     push a
0381                ;*********************************************    
0381            
0381                ; Tri-state data pin for input
0381 1A 32 [06]     mov  a,[gbThermPortMirror]
0383 0D 01 [04]     or   a,ThermData
0385 2A 00 [05]     iowr ThermPort
0387            
0387                ; ThermClock =0;
0387 1A 32 [06]     mov  a,[gbThermPortMirror]
0389 10 FD [04]     and  a,~ThermClock
038B 31 32 [05]     mov  [gbThermPortMirror],a
038D 2A 00 [05]     iowr ThermPort
038F            
038F                ; Read in data pin and check for 0 or 1
038F 29 00 [05]     iord ThermPort
0391 10 01 [04]     and  a,ThermData
0393 B3 97 [05]     jnz  ThermPortTempReadValue1
0395            
0395              ThermPortTempReadValue0:
0395 83 9B [05]     jmp  ThermPortTempReadClock
0397              ThermPortTempReadValue1:
0397                ; Use bitmask
0397 2E    [05]     push x
0398 2B    [04]     pop  a
0399 33 33 [07]     or   [gbThermTempRead],a
039B               ;jmp  ThermPortTempReadClock ; redundant, but good practice
039B            
039B              ThermPortTempReadClock:
039B                ; ThermClock =1;
039B 1A 32 [06]     mov  a,[gbThermPortMirror]
039D 0D 02 [04]     or   a,ThermClock
039F 31 32 [05]     mov  [gbThermPortMirror],a
03A1 2A 00 [05]     iowr ThermPort
03A3            
03A3                ; Next bit in mask
03A3 2E    [05]     push x
03A4 2B    [04]     pop  a
03A5 3B    [04]     asl  a
03A6 2D    [05]     push a
03A7 2C    [04]     pop  x
03A8            
03A8                ;*********************************************    
03A8                ; Finished?
03A8 2B    [04]     pop  a
03A9 25    [04]     dec  a
03AA B3 80 [05]     jnz  ThermPortTempReadLoop
03AC            
03AC                ;*********************************************    
03AC                ; Last bit
03AC                ;*********************************************    
03AC                ; Tri-state data pin for input
03AC 1A 32 [06]     mov  a,[gbThermPortMirror]
03AE 0D 01 [04]     or   a,ThermData
03B0 2A 00 [05]     iowr ThermPort
03B2            
03B2                ; ThermClock =0;
03B2 1A 32 [06]     mov  a,[gbThermPortMirror]
03B4 10 FD [04]     and  a,~ThermClock
03B6 31 32 [05]     mov  [gbThermPortMirror],a
03B8 2A 00 [05]     iowr ThermPort
03BA            
03BA                ; Read in data pin and check for 0 or 1
03BA 29 00 [05]     iord ThermPort
03BC 10 01 [04]     and  a,ThermData
03BE B3 C2 [05]     jnz  ThermPortTempReadLastValue1
03C0            
03C0              ThermPortTempReadLastValue0:
03C0 83 C6 [05]     jmp  ThermPortTempReadLastClock
03C2              ThermPortTempReadLastValue1:
03C2                ; Use bitmask
03C2 19 01 [04]     mov  a,1
03C4 31 34 [05]     mov  [gbThermTempRead2],a
03C6               ;jmp  ThermPortTempReadLastClock ; redundant, but good practice
03C6            
03C6              ThermPortTempReadLastClock:
03C6                ; ThermClock =1;
03C6 1A 32 [06]     mov  a,[gbThermPortMirror]
03C8 0D 02 [04]     or   a,ThermClock
03CA 31 32 [05]     mov  [gbThermPortMirror],a
03CC 2A 00 [05]     iowr ThermPort
03CE            
03CE 3F    [08]     ret
03CF            
03CF            ;//$PAGE
03CF            ;*******************************************************************************
03CF            ; ThermPortRead8Bits()
03CF            ; @func .
03CF            ; @parm BYTE | gbThermPortValue | Return read byte.
03CF            ;*******************************************************************************
03CF            ThermPortRead8Bits:
03CF            
03CF                ; Setup bitmask
03CF 19 01 [04]     mov  a,1
03D1 2D    [05]     push a
03D2 2C    [04]     pop  x
03D3            
03D3 19 08 [04]     mov  a,8
03D5             ThermPortValueReadLoop:
03D5 2D    [05]     push a
03D6                ;*********************************************    
03D6            
03D6                ; Tri-state data pin for input
03D6 1A 32 [06]     mov  a,[gbThermPortMirror]
03D8 0D 01 [04]     or   a,ThermData
03DA 2A 00 [05]     iowr ThermPort
03DC            
03DC                ; ThermClock =0;
03DC 1A 32 [06]     mov  a,[gbThermPortMirror]
03DE 10 FD [04]     and  a,~ThermClock
03E0 31 32 [05]     mov  [gbThermPortMirror],a
03E2 2A 00 [05]     iowr ThermPort
03E4            
03E4                ; Read in data pin and check for 0 or 1
03E4 29 00 [05]     iord ThermPort
03E6 10 01 [04]     and  a,ThermData
03E8 B3 EC [05]     jnz  ThermPortReadValue1
03EA            
03EA              ThermPortReadValue0:
03EA 83 F0 [05]     jmp  ThermPortReadClock
03EC              ThermPortReadValue1:
03EC                ; Use bitmask
03EC 2E    [05]     push x
03ED 2B    [04]     pop  a
03EE 33 31 [07]     or   [gbThermPortValue],a
03F0               ;jmp  ThermPortReadClock ; redundant, but good practice
03F0            
03F0              ThermPortReadClock:
03F0                ; ThermClock =1;
03F0 1A 32 [06]     mov  a,[gbThermPortMirror]
03F2 0D 02 [04]     or   a,ThermClock
03F4 31 32 [05]     mov  [gbThermPortMirror],a
03F6 2A 00 [05]     iowr ThermPort
03F8            
03F8                ; Next bit in mask
03F8 2E    [05]     push x
03F9 2B    [04]     pop  a
03FA 3B    [04]     asl  a
03FB 2D    [05]     push a
03FC 2C    [04]     pop  x
03FD            
03FD                ;*********************************************    
03FD                ; Finished?
03FD 2B    [04]     pop  a
03FE 25    [04]     dec  a
03FF 1F    [04]         XPAGE
0400 B3 D5 [05]     jnz  ThermPortValueReadLoop
0402            
0402 3F    [08]     ret
0403            
0403            ;//$PAGE
0403            ;*******************************************************************************
0403            ; ThermPortWrite8Bits()
0403            ; @func .
0403            ; @parm BYTE | gbThermPortValue | Value to write
0403            ;*******************************************************************************
0403            ThermPortWrite8Bits:
0403            
0403                ; Setup bitmask
0403 19 01 [04]     mov  a,1
0405 2D    [05]     push a
0406 2C    [04]     pop  x
0407            
0407 19 08 [04]     mov  a,8
0409              ThermPortWriteLoop:
0409 2D    [05]     push a
040A                ;*********************************************    
040A            
040A                ; Get bitmask
040A 2E    [05]     push x
040B 2B    [04]     pop  a
040C            
040C 11 31 [06]     and  a,[gbThermPortValue]
040E B4 1A [05]     jnz  ThermPortWriteValue1
0410            
0410              ThermPortWriteValue0:
0410                ; ThermData =0;
0410 1A 32 [06]     mov  a,[gbThermPortMirror]
0412 10 FE [04]     and  a,~ThermData
0414 31 32 [05]     mov  [gbThermPortMirror],a
0416 2A 00 [05]     iowr ThermPort
0418 84 22 [05]     jmp  ThermPortWriteValueClock
041A              ThermPortWriteValue1:
041A                ; ThermData =1;
041A 1A 32 [06]     mov  a,[gbThermPortMirror]
041C 0D 01 [04]     or   a,ThermData
041E 31 32 [05]     mov  [gbThermPortMirror],a
0420 2A 00 [05]     iowr ThermPort
0422               ;jmp  ThermPortWriteValueClock ; redundant, but good practice
0422            
0422              ThermPortWriteValueClock:
0422                ; ThermClock =0;
0422 1A 32 [06]     mov  a,[gbThermPortMirror]
0424 10 FD [04]     and  a,~ThermClock
0426 31 32 [05]     mov  [gbThermPortMirror],a
0428 2A 00 [05]     iowr ThermPort
042A            
042A                ; Next bit in mask
042A 2E    [05]     push x
042B 2B    [04]     pop  a
042C 3B    [04]     asl  a
042D 2D    [05]     push a
042E 2C    [04]     pop  x
042F            
042F                ; ThermClock =1;
042F 1A 32 [06]     mov  a,[gbThermPortMirror]
0431 0D 02 [04]     or   a,ThermClock
0433 2A 00 [05]     iowr ThermPort
0435            
0435                ;*********************************************    
0435                ; Finished?
0435 2B    [04]     pop  a
0436 25    [04]     dec  a
0437 B4 09 [05]     jnz  ThermPortWriteLoop
0439            
0439 3F    [08]     ret
043A            ;*****************************
043A            
043A            ;********************************************************
043A            ; SysDelayMS()
043A            ; @func Delay some number of milliseconds.
043A            ; @parm register | A | Number of milliseconds (0=65536).
043A            ; @comm Protects A and X registers.
043A            ;********************************************************
043A            SysDelayMS:
043A            
043A                ; Save em'
043A 2D    [05]     push a
043B 2E    [05]     push x
043C            
043C              SysDelayMSLoop:
043C                ; Save count
043C 2D    [05]     push a
043D            
043D                ; Delay 1ms = 10 * 100us
043D 19 0A [04]     mov  a,10
043F            
043F              SysDelayMSLoopDelay:
043F                ; Save it
043F 2D    [05]     push a
0440            
0440                ; Delay 100us
0440 19 64 [04]     mov  a,100
0442 94 4F [10]     call SysDelay
0444            
0444                ; Done?
0444 2B    [04]     pop  a
0445 25    [04]     dec  a
0446 B4 3F [05]     jnz  SysDelayMSLoopDelay
0448            
0448                ; Done?
0448 2B    [04]     pop  a
0449 25    [04]     dec  a
044A B4 3C [05]     jnz  SysDelayMSLoop
044C            
044C                ; Restore em'
044C 2C    [04]     pop  x
044D 2B    [04]     pop  a
044E 3F    [08]     ret
044F            
044F            ;********************************************************
044F            ; SysDelay()
044F            ; @func Delay some number of microseconds.
044F            ; @parm register | A | Number of microseconds (0=65536).
044F            ; @comm Protects A and X registers.
044F            ;********************************************************
044F            SysDelay:
044F            
044F                ; Save em'
044F 2D    [05]     push a
0450 2E    [05]     push x
0451            
0451              SysDelayLoop:
0451                ; Save count
0451 2D    [05]     push a
0452            
0452                ; Delay 1ms
0452 20    [04]     nop     ; 4 clock cycles (6Mhz or 166us cycle???)
0453 20    [04]     nop
0454 20    [04]     nop
0455 20    [04]     nop
0456 20    [04]     nop
0457 20    [04]     nop
0458 20    [04]     nop
0459 20    [04]     nop
045A 20    [04]     nop
045B 20    [04]     nop
045C            
045C                ; Done?
045C 2B    [04]     pop  a
045D 25    [04]     dec  a
045E B4 51 [05]     jnz  SysDelayLoop
0460            
0460                ; Restore em'
0460 2C    [04]     pop  x
0461 2B    [04]     pop  a
0462 3F    [08]     ret
0463            
0463            
0463            ;********************************************************
0463            ; Data Segment (ROM)
0463            ;********************************************************
0463            USBSendROMBufferBase:
0463            USBDeviceDescription:
0463 12    [00]     db 12h          ; Length
0464 01    [00]     db 01h          ; Type (1=device)
0465 00    [00]     db 00h,01h      ; Complies to USB Spec. v1.00
0466 01    [00] 
0467 00    [00]     db 00h          ; Class code (0=??)
0468 00    [00]     db 00h          ; SubClass code (0=??)
0469 00    [00]     db 00h          ; Protocol (0=none)(9.6.1)
046A 08    [00]     db 08h          ; Max. packet size for port0
046B B4    [00]     db B4h,04h      ; Vendor ID: (0x4B4=Cypress)
046C 04    [00] 
046D 02    [00]     db 02h,00h      ; Product ID (0x02=USB Thermometer)
046E 00    [00] 
046F 09    [00]     db 09h,00h      ; Device release v0.90
0470 00    [00] 
0471 01    [00]     db 01h          ; Manufacturer string descriptor index (0=none)
0472 02    [00]     db 02h          ; Product string descriptor index (0=none)
0473 00    [00]     db 00h          ; Serial number string descriptor index (0=none)
0474 01    [00]     db 01h          ; Number of possible configurations
0475            USBDeviceDescriptionEnd:
0475            
0475            ;*************************************************
0475            ;
0475            USBConfigurationDescription:
0475 09    [00]     db 09h          ; Length
0476 02    [00]     db 02h          ; Type (2=config)
0477 19    [00]     db 19h,00h   ; Total data length (1 config,1 interface,1 endpoints)
0478 00    [00] 
0479 01    [00]     db 01h          ; Interface supported (1=???)
047A 01    [00]     db 01h          ; Configuration value (1=???)
047B 04    [00]     db 04h          ; Confituration string descriptor index (0=none)
047C 80    [00]     db 80h          ; Configuration (80h=Bus powered)
047D 32    [00]     db 32h          ; Maximum power consumption in 2mA units
047E            USBConfigurationDescriptionEnd:
047E            
047E            ;*************************************************
047E            ;
047E            USBInterfaceDescription:
047E 09    [00]     db 09h          ; Length
047F 04    [00]     db 04h          ; Type (4=interface)
0480 00    [00]     db 00h          ; Number of interfaces (0 based)
0481 00    [00]     db 00h          ; Alternate settings
0482 01    [00]     db 01h          ; Number of endpoints (1 based) (9.6.3)
0483 00    [00]     db 00h          ; Class code (0=non-specified,1=kb,2=mouse,3=joystick ???)
0484 00    [00]     db 00h          ; Subclass code (0=???)
0485 00    [00]     db 00h          ; Protocol code (0=non-specified)
0486 05    [00]     db 05h          ; Interface string index (0=non-specified, 1,2,3,...)
0487            USBInterfaceDescriptionEnd:
0487            
0487            ;*************************************************
0487            ; Never used for EP0
0487            USBEndPointDescriptionInt:
0487 07    [00]     db 07h          ; Length
0488 05    [00]     db 05h          ; Type (5=endpoint)
0489 81    [00]     db 81h          ; Address (EP#=1 | [0x80=IN, 0=OUT])
048A 03    [00]     db 03h          ; Attribute (0=control,1=isochronous,2=bulk,3=interrupt)
048B 08    [00]     db 08h,00h      ; Max packet size
048C 00    [00] 
048D 0A    [00]     db 0Ah          ; Interval (10 ms)
048E            USBEndPointDescriptionIntEnd:
048E            
048E            ;*************************************************
048E            ;
048E            USBStringLanguageDescription:
048E 04    [00]     db 04h          ; Length
048F 03    [00]     db 03h          ; Type (3=string)
0490 09    [00]     db 09h          ; Language:  English
0491 01    [00]     db 01h          ; Sub-language: US
0492            
0492            USBStringDescription1:
0492 10    [00]     db 10h          ; Length
0493 03    [00]     db 03h          ; Type (3=string)
0494 43 00 ...      dsu "Cypress"
     79 00 70 00 72 00 65 00 73 00 73 00 
04A2            
04A2            USBStringDescription2:
04A2 18    [00]     db 18h          ; Length
04A3 03    [00]     db 03h          ; Type (3=string)
04A4 54 00 ...      dsu "Thermometer"
     68 00 65 00 72 00 6D 00 6F 00 6D 00 65 00 74 00 65 00 72 00 
04BA            
04BA            USBStringDescription3:
04BA                                ; If a SN is used, this must be unique
04BA                                ;    for every device or the device may
04BA                                ;    not enumerate properly
04BA            
04BA            USBStringDescription4:
04BA 20    [00]     db 20h          ; Length
04BB 03    [00]     db 03h          ; Type (3=string)
04BC 47 00 ...      dsu "Get Temperature"
     65 00 74 00 20 00 54 00 65 00 6D 00 70 00 65 00 72 00 61 00 74 00 75 00 72 00 
     65 00 
04DA            
04DA            USBStringDescription5:
04DA 3C    [00]     db 3Ch          ; Length
04DB 03    [00]     db 03h          ; Type (3=string)
04DC 45 00 ...      dsu "EndPoint1 10ms Interrupt Pipe"
     6E 00 64 00 50 00 6F 00 69 00 6E 00 74 00 31 00 20 00 31 00 30 00 6D 00 73 00 
     20 00 49 00 6E 00 74 00 65 00 72 00 72 00 75 00 70 00 74 00 20 00 50 00 69 00 
     70 00 65 00 
0516            
0516            USBSendROMBufferTail:
0516            
0516            CopyrightStrings:
0516 55 53 ...      ds "USB Thermometer Project, Version 1.01"
     42 20 54 68 65 72 6D 6F 6D 65 74 65 72 20 50 72 6F 6A 65 63 74 2C 20 56 65 
     72 73 69 6F 6E 20 31 2E 30 31 
053B 43 6F ...      ds "Copyright Slade Systems, Inc., July, 1997"
     70 79 72 69 67 68 74 20 53 6C 61 64 65 20 53 79 73 74 65 6D 73 2C 20 49 6E 
     63 2E 2C 20 4A 75 6C 79 2C 20 31 39 39 37 
0564 43 6F ...      ds "Copyright Marc Reinig, July, 1997"
     70 79 72 69 67 68 74 20 4D 61 72 63 20 52 65 69 6E 69 67 2C 20 4A 75 6C 79 
     2C 20 31 39 39 37 
0585 43 6F ...      ds "Copyright Cypress Semiconductors, Inc., July, 1997"
     70 79 72 69 67 68 74 20 43 79 70 72 65 73 73 20 53 65 6D 69 63 6F 6E 64 75 
     63 74 6F 72 73 2C 20 49 6E 63 2E 2C 20 4A 75 6C 79 2C 20 31 39 39 37 
05B7            

CheckSum = 733B
Warnings = 0
Errors   = 0

Product: CPU=63, RAM=128 bytes, ROM=4096K bytes

 ************ SYMBOLIC REFERENCE TABLE ************

Value  Label                # Uses 
-----  -------------------- ------
   4 = Button_Pin             3
 516   CopyrightStrings       0
  a2   Inc_Counter            1
   8 = LED_ON                 0
  66   Loop2                  2
  58   MainLoop               1
  80   MainLoopNoLEDUpdate    1
  86   STPortsRefresh         0
  d7   STimerDebounceOver     1
  bd   STimerNo1024usRoll     1
  db   STimerNoDebounce       3
  b5   Suspend_End            2
 44f   SysDelay               1
 451   SysDelayLoop           1
 43a   SysDelayMS             2
 43c   SysDelayMSLoop         1
 43f   SysDelayMSLoopDelay    1
  e4   SysGPIOButtonDebouncing   0
  df   SysGPIOEvent           1
  40 = SysIntGPIO             1
   1 = SysIntReserved0        0
  20 = SysIntReserved5        0
   4 = SysIntTimer1024us      2
   2 = SysIntTimer128us       0
   8 = SysIntUSBEndP0         3
  10 = SysIntUSBEndP1         0
  80 = SysIntWakeUp           0
  20 = SysInterrupt           9
   0 = SysPort0               4
  30 = SysPort0ISinkPin0      0
  31 = SysPort0ISinkPin1      0
  32 = SysPort0ISinkPin2      0
  33 = SysPort0ISinkPin3      0
  34 = SysPort0ISinkPin4      0
  35 = SysPort0ISinkPin5      0
  36 = SysPort0ISinkPin6      0
  37 = SysPort0ISinkPin7      0
   4 = SysPort0IntEnable      1
   8 = SysPort0PullUp         1
   1 = SysPort1               5
  38 = SysPort1ISinkPin0      0
  39 = SysPort1ISinkPin1      0
  3a = SysPort1ISinkPin2      0
  3b = SysPort1ISinkPin3      1
   5 = SysPort1IntEnable      2
   9 = SysPort1PullUp         1
  ff = SysStatus              2
  10 = SysStatusPowerOn       0
   2 = SysStatusReserved2     0
   4 = SysStatusReserved3     0
  80 = SysStatusReserved7     0
   1 = SysStatusRun           0
   8 = SysStatusSuspend       0
  20 = SysStatusUSBReset      0
  40 = SysStatusWDReset       0
  23 = SysTimer               0
  83   SysTimer1024usEvent    1
  22 = SysTimerExternal       0
  10   SysUnUsed              4
  21 = SysWatchDog            1
   2 = ThermClock             8
  ac = ThermConfigRead        2
   c = ThermConfigWrite       1
   2 = ThermControlCPUUse     4
  80 = ThermControlDone       1
  60 = ThermControlFlags      0
  10 = ThermControlNVB        0
   1 = ThermControlOneShot    2
  ee = ThermConvertStart      1
  22 = ThermConvertStop       0
  41 = ThermCounterLoad       0
  a0 = ThermCounterRead       0
   1 = ThermData              8
 310   ThermInitDone          1
 2f3   ThermInitialize        1
   7 = ThermMaskBits          0
   0 = ThermPort              19
 36d   ThermPortProtocolWrite   4
 35e   ThermPortRead          2
 3cf   ThermPortRead8Bits     1
 3f0   ThermPortReadClock     1
 37a   ThermPortReadTemperature   1
 3ea   ThermPortReadValue0    0
 3ec   ThermPortReadValue1    1
 336   ThermPortResetHigh     4
 341   ThermPortResetLow      4
 39b   ThermPortTempReadClock   1
 3c6   ThermPortTempReadLastClock   1
 3c0   ThermPortTempReadLastValue0   0
 3c2   ThermPortTempReadLastValue1   1
 380   ThermPortTempReadLoop   1
 395   ThermPortTempReadValue0   0
 397   ThermPortTempReadValue1   1
 3d5   ThermPortValueReadLoop   1
 353   ThermPortWrite         1
 403   ThermPortWrite8Bits    2
 409   ThermPortWriteLoop     1
 410   ThermPortWriteValue0   0
 41a   ThermPortWriteValue1   1
 422   ThermPortWriteValueClock   1
  a0 = ThermRead              0
 31b   ThermReadTemperature   1
   4 = ThermReset             2
  a9 = ThermSlopeRead         0
  a1 = ThermTempHighRead      0
   1 = ThermTempHighWrite     0
  a2 = ThermTempLowRead       0
   2 = ThermTempLowWrite      0
  aa = ThermTempRead          1
 348   ThermWaitForDone       1
 475   USBConfigurationDescription   1
 47e   USBConfigurationDescriptionEnd   0
  13 = USBControl             5
  10 = USBControlAckOutData   0
   8 = USBControlAckStatusData   2
   1 = USBControlBusActive    0
   4 = USBControlReserve2     0
  20 = USBControlReserve5     0
  40 = USBControlReserve6     0
  80 = USBControlReserve7     0
   2 = USBControlResume       0
   2 = USBDescriptorTypeConfig   1
   1 = USBDescriptorTypeDevice   1
   5 = USBDescriptorTypeEndPoint   0
   4 = USBDescriptorTypeInterface   0
   6 = USBDescriptorTypeReserved06   0
   3 = USBDescriptorTypeString   1
  12 = USBDeviceAddress       1
 463   USBDeviceDescription   1
 475   USBDeviceDescriptionEnd   0
  70 = USBEndP0FIFO           1
  70 = USBEndP0FIFO_0         4
  71 = USBEndP0FIFO_1         6
  72 = USBEndP0FIFO_2         6
  73 = USBEndP0FIFO_3         1
  74 = USBEndP0FIFO_4         3
  75 = USBEndP0FIFO_5         0
  76 = USBEndP0FIFO_6         1
  77 = USBEndP0FIFO_7         1
  10 = USBEndP0RxCount0       0
  20 = USBEndP0RxCount1       0
  40 = USBEndP0RxCount2       0
  80 = USBEndP0RxCount3       0
   8 = USBEndP0RxDataFlag     0
   4 = USBEndP0RxIn           0
   2 = USBEndP0RxOut          2
   1 = USBEndP0RxSetup        1
  14 = USBEndP0RxStatus       6
  10 = USBEndP0TxConfig       6
   1 = USBEndP0TxCount0       0
   2 = USBEndP0TxCount1       0
   4 = USBEndP0TxCount2       0
   8 = USBEndP0TxCount3       0
  80 = USBEndP0TxRespond      4
  10 = USBEndP0TxRxErr        0
  40 = USBEndP0TxSequence     3
  20 = USBEndP0TxStall        1
  78 = USBEndP1FIFO           0
  78 = USBEndP1FIFO_0         0
  79 = USBEndP1FIFO_1         0
  7a = USBEndP1FIFO_2         0
  7b = USBEndP1FIFO_3         0
  7c = USBEndP1FIFO_4         0
  7d = USBEndP1FIFO_5         0
  7e = USBEndP1FIFO_6         0
  7f = USBEndP1FIFO_7         0
  11 = USBEndP1TxConfig       0
   1 = USBEndP1TxCount0       0
   2 = USBEndP1TxCount1       0
   4 = USBEndP1TxCount2       0
   8 = USBEndP1TxCount3       0
  10 = USBEndP1TxEnable       0
  80 = USBEndP1TxRespond      0
  40 = USBEndP1TxSequence     0
  20 = USBEndP1TxStall        0
  e8   USBEndPoint0Event      1
 487   USBEndPointDescriptionInt   0
 48e   USBEndPointDescriptionIntEnd   0
  ef   USBEventEP0End         12
 15e   USBEventEP0SetupGetDescriptor   2
 174   USBEventEP0SetupGetDescriptorConfig   1
 160   USBEventEP0SetupGetDescriptorDevice   0
 1fe   USBEventEP0SetupGetDescriptorEnd   2
 18c   USBEventEP0SetupGetDescriptorString   1
 192   USBEventEP0SetupGetDescriptorString0   0
 1a4   USBEventEP0SetupGetDescriptorString1   1
 1b6   USBEventEP0SetupGetDescriptorString2   1
 1c8   USBEventEP0SetupGetDescriptorString3   1
 1da   USBEventEP0SetupGetDescriptorString4   1
 1ec   USBEventEP0SetupGetDescriptorString5   1
 12c   USBEventEP0SetupIsSetAddress   1
 132   USBEventEP0SetupIsSetConfig   0
 142   USBEventEP0SetupSetAddress   1
 14c   USBEventEP0SetupSetConfig   1
 116   USBEventEP0SetupTargetDeviceIN   0
 10a   USBEventEP0SetupTargetDeviceOUT   0
 11e   USBEventEP0SetupTargetEndpointIN   0
 112   USBEventEP0SetupTargetEndpointOUT   0
 11a   USBEventEP0SetupTargetInterfaceIN   0
 10e   USBEventEP0SetupTargetInterfaceOUT   0
 122   USBEventEP0SetupTargetVendorIN_OUT   0
  f3   USBEventEP0Stall       9
 287   USBEventEP0VendorRqst   1
 2e0   USBEventEP0VendorRqstFinish   5
 28a   USBEventEP0VendorRqstPing   0
 2b8   USBEventEP0VendorRqstReadPort   1
 2c2   USBEventEP0VendorRqstReadPort0   0
 2c6   USBEventEP0VendorRqstReadPort1   2
 2c8   USBEventEP0VendorRqstReadPortsDone   1
 29c   USBEventEP0VendorRqstReadRAM   1
 290   USBEventEP0VendorRqstReadROM   1
 2cc   USBEventEP0VendorRqstWritePort   1
 2d6   USBEventEP0VendorRqstWritePort0   0
 2dc   USBEventEP0VendorRqstWritePort1   0
 2e0   USBEventEP0VendorRqstWritePortsDone   1
 2aa   USBEventEP0VendorRqstWriteRAM   1
  ef   USBEventEP0_IN         0
  ef   USBEventEP0_OUT        0
  fb   USBEventEP0_SETUP      1
 47e   USBInterfaceDescription   0
 487   USBInterfaceDescriptionEnd   0
  4b = USBRawProtocolACK      0
  96 = USBRawProtocolIn       0
  5a = USBRawProtocolNAK      0
  87 = USBRawProtocolOut      0
  c3 = USBRawProtocolPort0    0
  d2 = USBRawProtocolPort1    0
  b4 = USBRawProtocolSetup    0
   1 = USBRqstClearFeature    0
   8 = USBRqstGetConfiguration   0
   6 = USBRqstGetDescriptor   1
   a = USBRqstGetInterface    0
   0 = USBRqstGetStatus       0
  71 = USBRqstMessage         2
   2 = USBRqstReserved02      0
   4 = USBRqstReserved04      0
   d = USBRqstReserved0D      0
   5 = USBRqstSetAddress      1
   9 = USBRqstSetConfiguration   1
   7 = USBRqstSetDescriptor   0
   3 = USBRqstSetFeature      0
   b = USBRqstSetInterface    0
   c = USBRqstSynchFrame      0
   0 = USBRqstTargetDevice    2
   2 = USBRqstTargetEndPoint   4
   1 = USBRqstTargetInterface   2
   3 = USBRqstTargetOther     0
  70 = USBRqstType            0
  20 = USBRqstTypeClass       0
  80 = USBRqstTypeDirection   5
  60 = USBRqstTypeMask        0
  60 = USBRqstTypeReserved    0
   0 = USBRqstTypeStandard    0
  40 = USBRqstTypeVendor      2
  73 = USBRqstWordValueHi     1
  72 = USBRqstWordValueLo     2
 26e   USBSendACK             2
 202   USBSendDescriptorCheckLength   8
 212   USBSendDescriptorCheckLengthEnd   3
 213   USBSendROMBuffer       8
 463   USBSendROMBufferBase   10
 516   USBSendROMBufferTail   0
 286   USBSendWaitComplete    2
 278   USBSendWaitForComplete   3
 492   USBStringDescription1   1
 4a2   USBStringDescription2   1
 4ba   USBStringDescription3   1
 4ba   USBStringDescription4   1
 4da   USBStringDescription5   1
 48e   USBStringLanguageDescription   1
 227   USendROMBufferLoop     1
 241   USendROMBufferLoopDone   2
 243   USendROMBufferLoopExit   1
 244   _USBSendROMBuffer      2
 26c   _USendROMBufferEnd     0
 247   _USendROMBufferLoop    1
 25a   _USendROMBufferLoopDone   1
  2d = gbButtonDebounce       6
  7a = gbButtonPushed         2
  2c = gbLEDBrightness        2
  2b = gbLEDBrightnessUpdate   3
  2e = gbPort0                2
  2f = gbPort1                3
  30 = gbSuspendCount         5
  50 = gbSysDataStack         0
  29 = gbSysEnumerated        4
  70 = gbSysFIFO              0
  20 = gbSysInterruptMask     11
   0 = gbSysProgramStack      0
  22 = gbSysTick1024us        2
  24 = gbSysTick1024usRoll    2
  32 = gbThermPortMirror      25
  31 = gbThermPortValue       10
  30 = gbThermProtocol        5
  78 = gbThermTempLast        1
  79 = gbThermTempLast2       1
  33 = gbThermTempRead        3
  34 = gbThermTempRead2       3
  28 = gbUSBSendBuffer        10
  27 = gbUSBSendBytes         17
  26 = gbUSBSendSequence      4
  25 = gbUSBValidRqsts        4
  15   main                   1
